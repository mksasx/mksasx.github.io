[{"content":"计算机网络体系结构 1. 计算机网络综述 * 1.1. 计算机网络概念 * 计算机网络就是一些互联的，自治的计算机的集合，它们通过通信设备和线路互相连接，由功能完善的软件实现资源共享和信息传递。\n广义观点：能实现远程信息处理的系统或能进一步达到资源共享的系统\n资源共享观点：目的——资源共享，组成单元——分布在不同地理位置的多台独立的“自治计算机”，网络中计算机必须遵循的统一规则——网络协议\n用户透明性观点：网络对用户透明，其描述了一个分布式系统\n1.2. 计算机网络组成 * 组成：硬件，软件，协议\n工作方式：边缘部分——通信+资源共享（由所有连接到因特网上，供用户直接使用的主机组成），核心部分——为边缘部分提供连通性和交换服务（网络、连接这些网络的路由器）\n功能：通信子网——传输介质、通信设备和相应网络协议，资源子网——实现资源共享的设备及其软件的集合\n1.3. 计算机网络的功能 * 数据通信：计算机网络最基本和最重要的功能 资源共享：提高硬件资源，软件资源和数据资源的利用率 分布式处理：利用空闲计算机资源提高整个系统利用率 提高可靠性：计算机网络中各台计算机可以通过网络互为替代机 负载均衡：工作任务均匀分配给网络中各台计算机 1.4. 计算机网络分类 * 1.4.1. 分布范围 * 广域网WAN：长距离通信（几十千米到几千千米），交换技术 城域网MAN：5-50km，以太网技术 局域网LAN：几十米到几千米，广播技术 个人区域网PAN：10m左右 1.4.2. 传输技术 * 广播式网络：所有联网计算机共享一个公共通信信道。局域网，广域网中的无线、通信卫星网络采用广播式通信。 点对点网络：每条物理线路连接一对计算机。广域网基本属于点对点网络。 是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别。\n1.4.3. 拓扑结构 * 总线形：单根传输线，建网容易，增/减结点方便、节省线路。重负载时通信效率不高，对任意一处故障敏感。（局域网） 星形：中央设备为交换机或路由器，便于集中控制和管理。成本高，中央设备对故障敏感。（局域网） 环形：所有计算机接口设备连成环，环中信号单向传输。（令牌环局域网） 网状网络：每个结点至少有两条路径与其他结点相连，可靠性高。控制复杂，线路成本高。（广域网） 1.4.4. 使用者 公用网/专用网\n1.4.5. 交换技术 * 电路交换网络：建立连接，传输数据，断开连接。 数据直接传送，时延小。 线路利用率低、不能充分利用线路容量、不便于进行差错控制。 报文交换网络(存储-转发网络）：用户数据+源地址、目的地址、校验码等，封装成报文，传送至相邻结点。 充分利用线路容量，实现不同链路之间不同数据传输速率的转换，格式转换，一对多/多对一访问，差错控制。 增大资源开销，缓冲时延，需要额外控制机制保证多个报文数据不乱序，缓冲区难以管理。 分组交换网络：数据分成较短的固定长度数据块，在每个数据块中加上源地址、目的地址等辅助信息组成分组（包）已存储-转发方式传输，封装成报文单个分组发送到相邻结点。 除具有报文交换网络的优点外，缓冲易于管理，包的平均时延更校，网络占用平均缓冲区更少，更易于标准化，更适合应用 1.4.6. 传输介质 有线网络：双绞线网络，同轴电缆网络等。 无线网络：蓝牙，微波，无线电等。 1.5. 计算机网络性能指标 * 带宽：网络通信线路传送数据的能力（比特/秒） 时延：数据（一个报文或分组）从网络（或链路）一端发送到另一端的总时间。总时延=发送时延+传播时延+处理时延+排队时延（通常忽略后两者） 发送时延：发送时延=分组长度/信道宽度 传播时延：传播时延=信道长度/电磁波在信道上传播速率 处理时延：数据在交换结点为存储转发进行的一些必要的处理花费的时间。 排队时延：分组在进入路由器后先在输入队列中排队等待处理，在输出队列中排队等待转发的时间。 时延带宽积：传播时延 × 信道带宽 往返时延：发送端发出一个短分组，到发送端收到来自接收端的确认总共经历的时延。 吞吐量：单位时间内通过某个网络（或者信道/接口）的数据量。 速率：数据传输速率，最高数据传输速率称为带宽 信道利用率：有数据通过时间/（有+无）数据通过时间 电路交换：s+$\\frac{x}{b}$+kd 分组交换：kd+(k-1)*$\\frac{p}{b}$+$\\lceil \\frac{x}{p} \\rceil \\times \\frac{p}{b}$ 2.计算机网络体系结构与参考模型 * 2.1. 计算机网络分层结构 分层基本原则：\n每层实现独立功能，降低大系统复杂度 各层之间界面自然清晰，易于理解，相互交流尽可能少 各层功能精确定义独立于具体实现方法 保持下层对上层的独立性，上层单向使用下层服务 整个分层结构应能促进标准化工作 层数过多，功能在不同层中重复出现，产生额外开销，导致运行效率降低\n层数过少，会使每层协议太复杂\n报文=服务数据单元(SDU)+协议控制信息(PCI)=协议数据单元(PDU) n-SDU+n-PCI=n-PDU=(n-1)-SDU 如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。 具体地，层次结构的含义包括以下几方面：\n1)第n层的实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向第n+1层提\n供本层的服务，该服务是第n层及其下面各层提供的服务总和。\n2)最低层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是\n上一层的服务提供者；最高层面向用户提供服务。\n3)上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层\n所提供服务的实现细节对上一层透明。\n4)两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到\n对方。\n2.计算机网络协议/接口/服务 2.2.1.协议 定义：是控制两个(或多个)对等实体进行通信的规则的集合，由语法，语义，同步三部分组成。\n语法：规定传输数据的格式 语义：规定索要完成的功能 同步：规定了执行各种操作的条件，时序关系等 完整的协议通常应该具有线路管理，差错控制，数据转换等功能。\n2.2.2.接口 定义：是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。\n同一结点相邻两层实体通过服务访问点(SAP)交互——————服务是通过SAP提供给上层使用的，第n层的\nSAP就是第n+1层可以访问第n层服务的地方。\n2.2.3.服务 定义：下层为紧邻的上层提供的功能调用。\nOSI参考模型的原语分类：\n请求：服务用户发往服务提供者，请求完成某项工作 指示：服务提供者发往服务用户，指示用户做某件事 响应：服务用户发往服务提供者，作为对指示的响应 证实：服务提供者发往服务用户，作为对请求的证实 协议，接口，服务相互关系\n只有本层协议的实现才能保证向上层提供服务 本层的服务用户只能看到服务而无法看到下面的协议 协议是\u0026#34;水平的\u0026#34;，协议是控制对等实体之间通信的规则 服务是\u0026#34;垂直的\u0026#34;，服务是由下层通过层间接口向上层提供的 面向连接服务：通信前需要建立连接，分配资源，释放连接和占用的资源。可以分为连接建立、数据传输和连接释放三个阶段 无连接服务（尽最大努力交付）：通信前不需要建立连接，需要发送数据可直接发送，属于不可靠服务 可靠服务：网络具有纠错，检错，应答机制，保证数据正确，可靠地传送到目的地 不可靠服务：网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。不可靠服务的网络的可靠性由应用和用户来保障。 有应答服务：接收方收到数据后向发送方给出相应应答，该应答由传输系统内部自动实现，而不由用户实现。例如文件传输服务 无应答服务：接收方收到数据后不自动给出应答。若需要应答，则由高层实现（www服务） 2.3. ISO/OSI参考模型与TCP/IP模型 * 2.3.1. OSI参考模型（开放系统互连参考模型） * 名称 层数 传输单位 任务 功能 协议/规程/接口标准 属于 物理媒体 0 物理层 1 比特 透明的传输比特流 在物理媒体上传输原始比特流 EIA-232C/CCITT的X.21等 通信子网 数据链路层 2 帧 将网络层传来的IP数据报组装成帧 成帧，差错控制，流量控制和传输管理 SDLC。HDLC，PPP，STP等 通信子网 网络层 3 数据报 把网络层PDU（协议数据单元）（分组)从源端传到目的端，为分组交换网上不同主机提供通信服务 对分组进行路由选择，实现流量控制，拥塞控制，差错控制，网际互连 IP，IPX，ICMP，IGMP，ARP，RARP，OSPF 通信子网 传输层 4 报文段(TCP)或用户数据报(UDP) 负责主机中两个进程间的通信 为端到端连接提供可靠的服务，流量控制，差错控制，服务质量，数据传输管理等服务 TCP，UDP 承上启下 会话层 5 向表示层提供它的增值服务 管理主机间会话进程，实现数据同步 资源子网 表示层 6 处理两个通信系统中交换信息的表示方式 采用抽象的标准方法定义数据结构，采用标准的编码形式 资源子网 应用层 7 为特定类型的网络应用提供访问OSI参考模型环境的手段 采用不同应用协议解决不同类型应用要求 文件传送FTP，电子邮件SMTP，万维网HTTP 资源子网 2.3.2. TCP/IP模型 * 名称 对象 功能 协议 网络接口层 主机-网络 从主机或结点接受IP分组，并把它们发送到指定物理网络上 主机必须使用某种协议与网络连接 网际层 主机-主机 将分组发往任何网络，并为之独立选择合适路由 定义标准分组格式和协议IP(IPv4/IPv6) 传输层 应用-应用\n进程-进程 使得发送端和目的端主机上的对等实体进行会话 传输控制协议(TCP)：面向连接，单位为报文段,提供可靠交付\n用户数据报协议(UDP)：无连接，单位为用户数据报，尽最大努力交付 应用层 用户-用户 包含所有高层协议 虚拟终端协议Telnet，文本传输协议FTP，域名解析服务DNS，电子邮件协议SMTP，超文本传输协议HTTP 2.3.3. OSI模型与TCP/IP模型的比较 * 相似点：\n均采用分层的体系结构，分层功能大体相似 均基于独立的协议栈的概念 均可解决异构网络互联，实现不同计算机之间通信 不同点：\nOSI精确定义服务，协议，接口；TCP/IP没有明确区分 OSI没有偏向于任何特定的协议，通用性良好；TCP/IP则是对已有的协议的描述 TCP/IP考虑到了异构网络互联问题，将网际协议(IP)作为一个单独重要层次；OSI在后来只能在网络层中划分子层完成类似的功能 OSI网络层支持无连接和面向连接通信，在传输层仅有面向连接通信；TCP/IP在网际层仅有无连接通信，而在传输层支持无连接和面向连接通信 ","permalink":"https://mksasx.github.io/posts/tech/net/computer_network_architecture/","summary":"计算机网络体系结构 1. 计算机网络综述 * 1.1. 计算机网络概念 * 计算机网络就是一些互联的，自治的计算机的集合，它们通过通信设备和线路互相连接，由功能完","title":"计算机网络体系结构笔记"},{"content":"球星赛场照 ","permalink":"https://mksasx.github.io/posts/sport/bas_wallpaper/","summary":"一些篮球有关的壁纸","title":"篮球壁纸"},{"content":"写文章 快速写文章 输入hugo new 文章名称.md就会在content目录下生成 “文章名称.md” 名字的文件，所有文章都是放在content这个文件夹里\n如果自己还定义了分类目录，如在content目录的posts目录下有blog、read、tech、life等文章分类，那么在用命令生成文章的时候，如果要把文章生成到指定目录，可以用命令：hugo new posts/tech/文章名称.md，这样就会把文章生成到tech目录下\n生成的文章内部头部配置信息包括一些文章名称，时间之类的信息，可以事先在目录archetypes/default.md下使用模板，这样在用命令hugo new生成文章后会自动加上模板里的配置\n文章基本模板 --- title: \u0026#34;Blog\u0026#34; date: 2022-05-05T00:18:23+08:00 lastmod: 2022-05-05T00:18:23+08:00 author: [\u0026#34;AustinMa\u0026#34;] keywords: - 建站指南 categories: - 建站指南 tags: - blog description: \u0026#34;这是一些基础的建站指南\u0026#34; weight: 1 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true reward: true # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 cover: image: \u0026#34;\u0026#34; #图片路径例如：posts/tech/123/123.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; --- 文章插入图片 在文章里面使用本地图片的方式：\n比如我在content/posts/tech/下有一篇文章叫做 fft.md，那么在和该文章同一目录下新建一个文件夹叫做fft，里面放图片如叫做 picture.png 的图片，那么在fft.md里面调用的时候可以这样写: ![](picture.png)\n部署问题 写完文章更新Public hugo --theme=hugo-PaperMod --baseUrl=\u0026#34;https://mksasx.github.io/\u0026#34; --buildDrafts 或者\nhugo -F --cleanDestinationDir 部署到github样式不显示 错误描述 在 Github Pages 上部署 Hugo 博客后，网站样式丢失，打开浏览器 F12 控制台可以发现错误：Failed to find a valid digest in the 'integrity' attribute for resource \u0026quot;xxx.css\u0026quot;, The resource has been blocked.\n错误解决 将\\layouts\\partials\\head.html以及themes\\hugo-PaperMod\\layouts\\partials里的integrity=\u0026quot;{{ $stylesheet.Data.Integrity }}\u0026quot; 这么一句代码，把它改为 integrity=\u0026quot;\u0026quot; 然后重新发布\n有些使用者会部署到github，可能遇到跨系统的问题，如提示LF will be replaced by CRLF in ******，这时输入命令：git config core.autocrlf false，解决换行符自动转换的问题。\n提示LF will be replaced by CRLF in **** 错误描述 git add时提示LF will be replaced by CRLF in ****\n错误解决 输入命令：git config core.autocrlf false，解决换行符自动转换的问题。\n","permalink":"https://mksasx.github.io/posts/tech/blog/blog/","summary":"写文章 快速写文章 输入hugo new 文章名称.md就会在content目录下生成 “文章名称.md” 名字的文件，所有文章都是放在content这个文","title":"Blog"},{"content":"《Can you feel my love tonight》 \u003c!DOCTYPE HTML\u003e\r《Free Loop》 \u003c!DOCTYPE HTML\u003e\r《知足（阿卡贝拉）》 \u003c!DOCTYPE HTML\u003e\r《知足》 \u003c!DOCTYPE HTML\u003e\r《贝加尔湖畔（阿卡贝拉）》 \u003c!DOCTYPE HTML\u003e\r","permalink":"https://mksasx.github.io/posts/music/%E4%B8%AA%E4%BA%BA%E8%A1%A8%E6%BC%94%E5%90%88%E9%9B%86/","summary":"个人表演合集，阿卡贝拉","title":"个人一些表演合集"},{"content":"#include\u0026lt;bits/stdc++.h\u0026gt; #define N 2621450 #define pi acos(-1) using namespace std; typedef complex\u0026lt;double\u0026gt; E; int n,m,l,r[N]; E a[N],b[N]; void fft(E *a,int f){ for(int i=0;i\u0026lt;n;i++)if(i\u0026lt;r[i])swap(a[i],a[r[i]]); for(int i=1;i\u0026lt;n;i\u0026lt;\u0026lt;=1){ E wn(cos(pi/i),f*sin(pi/i)); for(int p=i\u0026lt;\u0026lt;1,j=0;j\u0026lt;n;j+=p){ E w(1,0); for(int k=0;k\u0026lt;i;k++,w*=wn){ E x=a[j+k],y=w*a[j+k+i]; a[j+k]=x+y;a[j+k+i]=x-y; } } } } inline int read(){ int f=1,x=0;char ch; do{ch=getchar();if(ch==\u0026#39;-\u0026#39;)f=-1;}while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;); do{x=x*10+ch-\u0026#39;0\u0026#39;;ch=getchar();}while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;); return f*x; } int main(){ n=read();m=read(); for(int i=0;i\u0026lt;=n;i++)a[i]=read(); for(int i=0;i\u0026lt;=m;i++)b[i]=read(); m+=n;for(n=1;n\u0026lt;=m;n\u0026lt;\u0026lt;=1)l++; for(int i=0;i\u0026lt;n;i++)r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); fft(a,1);fft(b,1); for(int i=0;i\u0026lt;=n;i++)a[i]=a[i]*b[i]; fft(a,-1); for(int i=0;i\u0026lt;=m;i++)printf(\u0026#34;%d \u0026#34;,(int)(a[i].real()/n+0.5)); } flowchart LR a--\u003eb \u0026 c--\u003ed ","permalink":"https://mksasx.github.io/posts/tech/algorithm/fft/","summary":"算法，快速傅里叶变化模板","title":"FFT模板"},{"content":"物理层 1. 通信基础 * 1.1. 基本概念 * 1.1.1. 数据，信号与码元 * 通信的目的是传送信息\n数据：传送信息的实体\n信号：数据在传输过程中的存在形式\n模拟信号/数据：连续变化的信号/数据 数字信号/数据：取值仅允许为几个有限的几个离散数值的信号/数据 码元：数字通信中数字信号的计量单位，用一个固定时长的信号波形表示一位k进制数字。时长内的信号称之为k进制码元，时长称之为码元宽度\n1.1.2. 信源，信道与信宿 * 数字通信系统主要划分为信源、信道和信宿。\n信源是产生和发送数据的源头 信宿是接受数据的终点 信道是信号的传输媒介 信道分类\n传输信号形式：模拟信道/数字信道 传输介质：无线信道/有线信道 信号分类\n基带信号（基带传输）/宽带信号（宽带传输） 基带信号将数字信号1和0直接用两种不同的电压表示，然后送到数字信道上传输(称为基带传输); 宽带信号将基带信号进行调制后形成频分复用模拟信号，然后传送到模拟信道上去传输(称为宽带传输)。 通信交互方式\n单向通信：一条信道，无线电广播，电视广播 半双工通信：两条信道，通信的双方都可以发送或接收信息，任何一方不能同时发送和接收 全双工通信：两条信道，两个方向的数据传输可以同时进行，通信双方可以同时发送和接收信息 1.1.3. 速率，波特与带宽 * 速率：数据率，数据传输速率\n码元传输速率（波特率）：单位时间内传输的码元数，单位波特,可以是多进制。码元速率与进制数无关。（比如说2个二进制数组成一个码元，那他就是四进制的） 信息传输速率：单位时间内传输的二进制码元个数（比特数），单位比特/秒 注意：波特和比特是两个不同的概念，码元传输速率也称调制速率、波形速率或符号速率。但码元传输速率与信息传输速率在数量上却又有一定的关系。若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为Mn比特/秒。\n带宽：网络的通信线路所能传输数据的能力，表示单位时间内从网络中一点到另一点所能通过的\u0026quot;最高数据率\u0026quot;，单位b/s（Hz）\n1.2. 奈奎斯特定理/香农定理 * 1.2.1. 奈氏准则 * 理想低通信道下极限数据传输速率= $2W\\log_2{V}$ ，其中W为理想低通信道带宽，V为每个码元离散电平数目。\n任何信道码元传输速率有上限，超过上限会产生码间串扰 信道频带越宽，信道传输速率越高 奈氏准则规定码原传输速率，却并未限制码元可以有多少个二进制位。 1.2.2. 香农定理 * 香农定理是奈氏准则的推广，它规定了信息传输速率的上限，即信道的最大信息传输速率= $W\\log_{2}{(1+S/N)}$ ，其中W为信道带宽，S/N为信噪比。\n信噪比= $10log_{10}(S/N)$ ，单位dB\n信道带宽或信道中信噪比越大，信息极限传输速率越高 传输带宽和信噪比确定，信息传输速率上限确定 信息传输速率低于信道极限传输速率，就能找到某种方法实现无差错传输。 奈氏准则只考虑了带宽与极限码元与传输速率的关系，而香农定理不仅考虑了带宽，也考虑了信噪比。从侧面表明，一个码元对应的二进制位数是有限的\n1.3. 编码与调制 把数据变换为模拟信号的过程称为调制，把数据变换为数字信号的过程称为编码。\n1.3.1. 数字数据编码为数字信号 归零编码(RZ) 非归零编码(NRZ) 反向非归零编码(NRZI) 曼彻斯特编码(以太网) 差分曼彻斯特编码(局域网) 4B/5B编码 1.3.2. 数字数据编码为模拟信号 ASK幅移键控 FSK频移键控 PSK相移键控 QAM正交振幅调制 1.3.3. 模拟数据编码为数字信号 采样：时间上连续的信号变为离散的信号 量化：连续信号的幅度变为离散的数字量 编码：量化的结果转换为与之对应的二进制编码 1.3.4. 模拟数据编码为模拟信号 1.4.电路交换/报文交换/分组交换 * 1.4.1.电路交换 * 连接建立，数据传输，连接释放 用户始终占用端到端的固定传输宽带 优点：\n通信时延小 有序传输 没有冲突 适用范围广 实时性强 控制简单 缺点：\n建立连接时间长 线路独占 灵活性差 难以规格化 1.4.2.报文交换 * 报文携带目标地址，源地址等信息，在交换节点采用存储转发的传输方式。 优点：\n无需建立连接 动态分配线路 提高线路可靠性 提高线路利用率 提供多目标服务 缺点：\n引起转发时延 报文大小没有限制，要求网络结点有较大缓存空间。 1.4.3. 分组交换 * 限制每次传送数据块大小的上限，把大数据块划分为合理的小数据块，加上控制信息，构成分组。 优点：\n无建立时延 线路利用率高 简化存储管理 加速传输 减少出错概率和重发数据量。 缺点：\n存在传输时延 需要传输额外信息量 分组采用数据报形式的时候，可能出现失序、丢失或者重复分组。 1.5.数据报与虚电路 1.5.1.数据报 无连接的，不可靠的，尽最大努力交付的服务。 发送的分组包括发送端和接收端的完整地址。 分组在交换节点中采用存储转发的方式传输，需要排队等候处理，造成时延。 网络具有冗余路径。 存储转发延时一般较小，提高网络吞吐量。 收发双方不独占某条链路，资源利用率高。 1.5.2.虚电路 发送方和接收方建立一条逻辑上相连的虚电路。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放。 每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号。 虚电路通信链路建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高。 虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径 虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外，还可以对两个数据端点的流量进行控制。 网络中某个结点或某条链路出现故障而彻底失效时，所有经过该结点或链路的虚电路将遭到破坏。 分组首部不包含目的地址，包含的是虚电路标识符，相对于数据报方式，其开销小。 数据报服务 虚电路服务 连接的建立 不需要 必须有 目的地址 每个分组都有完整的目的地址 仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号 路由选择 每个分组独立地进行路由选择和转发 属于同一条虚电路的分组按照同一路由转发 分组顺序 不保证分组有序到达 保证分组有序到达 可靠性 不保证可靠通信，可靠性由用户主机保证 可靠性由网络保证 对网络故障的适应性 出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输 所有经过故障结点的虚电路不能正常工作 差错处理和流量控制 由用户主机进行流量控制，不保证数据报的可靠性 可由分组交换网负责，也可由用户主机负责 2. 传输介质 * 2.1. 双绞线，同轴电缆，光纤与无线传输介质 * 双绞线:绞合减少相邻导线的电磁干扰，局域网/传统电话线 无屏蔽双绞线 屏蔽双绞线（金属丝编织成的屏蔽层） 同轴电缆:内导体，绝缘层，网状编织屏蔽层和塑料外层，用于传输较高速率的数据 光纤:光脉冲 通信容量非常大 传输损耗小，中继距离长，对远距离传输特别经济 抗雷电和电磁干扰性能好 无串音干扰，保密性好，不易被窃听或截取数据 体积小，重量轻 无线传输介质 无线电波 微波，红外线和激光 2.2. 物理接口的特性 机械特性 电气特性 功能特性 过程特性 3. 物理层设备 * 3.1. 中继器 * 将信号整形并放大转发，以扩大网络传输距离（信号再生）\n中继器两端的网络部分是网段，而不是子网，使用中继器连接的几个网段仍然是一个局域网。\n不能连接两个不同速率的局域网\n注意：如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议；如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议，中继器没有存储转发功能，因此它不能连接两个选率不同的网段，中继器两端的网段一定要使用同一个协议。\n5-4-3规则:4个中继器串联的5段通信介质只有3段可以挂接计算机。\n放大器和中继器都起放大作用，只不过放大器放大的是模拟信号，原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。\n3.2. 集线器 * 多端口中继器，作信号放大和转发作用，扩大网络传输范围\n至多有一个端口接收输入，整形放大后转发到所有处于工作状态的端口。（若有两个或以上端口输入，输出时会有冲突，导致数据都无效）\n在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力，即信号传输的方向是固定的，是一个标准的共享式设备。\n主要使用双绞线组件共享网络\n不能分割冲突域\n比如，一个带宽为10Mb/s的条线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s=1.25Mb/s.\n","permalink":"https://mksasx.github.io/posts/tech/net/physical_layer/","summary":"物理层 1. 通信基础 * 1.1. 基本概念 * 1.1.1. 数据，信号与码元 * 通信的目的是传送信息 数据：传送信息的实体 信号：数据在传输过程中的存在形式 模拟信号/数据：连","title":"物理层笔记"},{"content":"进攻站位 一内四外 单堆叠 防守站位 关门战术\r","permalink":"https://mksasx.github.io/posts/sport/%E7%AF%AE%E7%90%83%E5%9F%BA%E6%9C%AC%E6%88%98%E6%9C%AF%E5%8F%8A%E5%9B%BE%E8%A7%A3/","summary":"篮球基本战术及图解","title":"篮球基本战术及图解"},{"content":"编译设计文档 姓名：马泽远\n学号：20373793\n一. 参考编译器介绍 Pcode代码生成部分（包括Pcode代码执行）部分参考了《自己动手写编译器》。\n其余部分参考了往年的编译指导文档，包括一些往届学长的编译器设计架构\n二. 编译器总体设计 总体结构 我的编译器总体结构按照编译的顺序，即词法分析、语法分析、语义分析、代码生成，分为四个部分。\n有几个类用来定义基本的一些需要用到的变量，比如**TokenWord类对应着单词类**，其属性包括单词内容，类别码，所在行数。类似的，还有**Symbol类对应着符号类**,Expressions类对应着表达式类,用于表示一个具有多个表达式的大表达式，以及**SymbolTable类对应着符号表类**，Func类对应着函数类，还有**Error类**。\n另外的几个类，则是分别对应着相应的几个编译器执行过程，LexicalAanlysis类对应词法分析，GrammarAanlysis类综合了语法分析，语义分析、错误处理，以及生成中间代码（Pcode码）\n而对于Pcode的定义，执行则是单独设置了一个文件包**PcodeGeneration,其中包含对Pcode的Function、Execute，retinfo，variety**以及其本身。\nCompiler类对应着编译器的总入口。在其中，依次调用**LexicalAanlysis，GrammarAanlysis，PcodeExecutor类，即可完成词法分析到语法分析到语义分析到代码生成的整个过程，形成了类似一个单向链**，每一个部分都是一个单独的模块。\n文件组织 src │ Compiler.java #入口程序 │ Error.java #错误类 │ Expressions.java #表达式类 │ Func.java #函数类 │ GrammarAnalysis.java #语法分析、错误处理、代码生成类 │ lexicalAnalysis.java #词法分析类 │ Symbol.java #符号类 │ SymbolTable.java #符号表类 │ TokenWord.java #单词类 └─PcodeGeneration Function.java #Pcode中的函数类 LabelCreator.java #标签制造 Pcode.java #Pcode代码类 PcodeExecutor.java #Pcode运行虚拟机类 PcodeKey.java #枚举Pcode中的关键词 RetInfo.java #返回信息类 Variety.java #变量类 类图 三. 词法分析设计 1 总述 词法分析的总任务是从源程序中识别出单词，记录单词类别和单词值。在词法分析的设计中给了一张表，其中有三项是加粗说明的，分别是 变量名（Ident），整常数（IntConst） 和 格式字符串（FormatString） 而剩下都可以认为是 特殊字符。\n词法分析的作业本质上就是把文件转换成一个个的词，在之后的文章中我们称之为 TokenWord。然后再把分出来的**TokenWord**进行类别的判断，最后输出。\n2 实现 2.1 文件读写 InputStreamReader Reader = new InputStreamReader(new FileInputStream(\u0026#34;testfile.txt\u0026#34;), \u0026#34;UTF-8\u0026#34;); BufferedReader bufferedReader = new BufferedReader(Reader); OutputStreamWriter Writer = new OutputStreamWriter(new FileOutputStream(\u0026#34;output.txt\u0026#34;), \u0026#34;UTF-8\u0026#34;); BufferedWriter bufferedWriter = new BufferedWriter(Writer); 利用bufferedReader逐行读入文件，注意需要手动加入换行符（最后添加的一个要删掉）\nwhile ((line = bufferedReader.readLine()) != null) { str.append(line).append(\u0026#34;\\n\u0026#34;); } str.delete(str.length() - 1, str.length()); 将lexicalAnalysis中分析得到的tokenWords写出\nfor(TokenWord tokenWord :lexicalAnalysis.tokenWords) { bufferedWriter.write(tokenWord.getClassCode()+\u0026#34; \u0026#34;+ tokenWord.getToken()+\u0026#34;\\n\u0026#34;); } 2.2 词法分析过程 准备工作 标识符定义采用enum枚举ClassCode的方法\npublic static enum ClassCode { IDENFR, INTCON, STRCON, ...... 同时采用HashMap构造一些特定标识符的对应关系\npublic static HashMap\u0026lt;String, String\u0026gt; ResCode = new HashMap\u0026lt;String, String\u0026gt;(); public static boolean hasResCode(String token) { return ResCode.containsKey(token); } static { ResCode.put(\u0026#34;main\u0026#34;, \u0026#34;MAINTK\u0026#34;); ResCode.put(\u0026#34;const\u0026#34;, \u0026#34;CONSTTK\u0026#34;); ...... 具体分析 总体采取逐个字符读入的方式，同时一些特定字符采取预读取来判断。\n逐个字符读入 public void getCh() { ch = allFile.charAt(cursor); cursor++; } 跳过换行、空格、\\t、\\r while (ch == \u0026#39;\\n\u0026#39; || ch == \u0026#39; \u0026#39; || ch == \u0026#39;\\t\u0026#39; || ch == \u0026#39;\\r\u0026#39;) { if (ch == \u0026#39;\\n\u0026#39; || ch == \u0026#39;\\r\u0026#39;) { LineNum++; } if (cursor \u0026lt;= allFile.length() - 1) { getCh(); } } 标识符 字母或者下划线开头，先从ResCode看是否是保留字,否则按照IDNEFR处理\nif (isLetter(ch) || ch == \u0026#39;_\u0026#39;) { while (isLetter(ch) || isDigit_with_0(ch) || ch == \u0026#39;_\u0026#39;) { Token.append(ch); if (cursor \u0026lt;= allFile.length() - 1) { getCh(); } } //reback if (cursor \u0026gt; 0) { cursor--; } if (hasResCode(Token.toString())) { classCode = ClassCode.valueOf(ResCode.get(Token.toString())); tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } else { classCode = ClassCode.IDENFR; tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } INTCON 先判断是否是0\nif (isDigit_with_0(ch)) { if (ch == \u0026#39;0\u0026#39;) { Token.append(ch); } else { while (isDigit_with_0(ch)) { Token.append(ch); getCh(); } if (cursor \u0026gt; 0) { cursor--; } classCode = ClassCode.INTCON; tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } } 字符串 遇到\u0026quot;开始，直到遇到下一个\u0026quot;\nif (ch == \u0026#39;\u0026#34;\u0026#39;) { Token.append(ch); if (cursor \u0026lt;= allFile.length() - 1) { getCh(); } while (cursor \u0026lt;= allFile.length() - 1 \u0026amp;\u0026amp; ch != \u0026#39;\u0026#34;\u0026#39;) { Token.append(ch); getCh(); } Token.append(ch); classCode = ClassCode.STRCON; tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } 单个字符或者必须两个字符的TokenWord 比如[，]，+，\u0026amp;\u0026amp;等，直接读就可以\n可能是单个也可能两个字符的TokenWord 比如\u0026gt;=，!=之类的\n采用预读\nif (ch == \u0026#39;=\u0026#39;) { Token.append(ch); if (cursor \u0026lt;= allFile.length() - 1) { getCh(); if (ch == \u0026#39;=\u0026#39;) { Token.append(ch); classCode = ClassCode.EQL; tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } else { classCode = ClassCode.ASSIGN; if (cursor \u0026gt; 0) { cursor--; } tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } } else { classCode = ClassCode.ASSIGN; tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } } 注释 遇到/的情况下，采用预读\n//：并且一直读到遇到换行符\n/*：利用BackStr = allFile.substring(cursor);提取出第一个*后面的字符串BackStr；然后判断其中有没有*/，若是没有，就将后面的内容全部注释掉，若是有就将cursor移动到其后面，但是注意要遇到换行符时加行数。\n否则/：直接按照DIV输出\nif (ch == \u0026#39;/\u0026#39;) { Token.append(ch); if (cursor \u0026lt;= allFile.length() - 1) { getCh(); if (ch == \u0026#39;/\u0026#39;) { if (cursor \u0026lt;= allFile.length() - 1) { getCh(); } while (ch != \u0026#39;\\n\u0026#39;) { if (cursor \u0026lt;= allFile.length() - 1) getCh(); else { noteFlag = true; break; } } if (!noteFlag) { LineNum++; } noteFlag = false; return -2; } else if (ch == \u0026#39;*\u0026#39;) { String BackStr; boolean flagnote; int cursortmp = cursor; BackStr = allFile.substring(cursor); if (!BackStr.contains(\u0026#34;*/\u0026#34;)) { cursor = allFile.length(); return -2; } else { cursor = cursor + BackStr.indexOf(\u0026#34;*/\u0026#34;) + 2; int originLength = allFile.substring(cursortmp, cursor).length(); int replaceLength = allFile.substring(cursortmp, cursor).replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).length(); LineNum += originLength - replaceLength; return -2; } } else { classCode = ClassCode.DIV; if (cursor \u0026gt; 0) { cursor--; } tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } } else { classCode = ClassCode.DIV; tokenWords.add(new TokenWord(classCode.toString(),Token.toString(),LineNum)); } } 四. 语法分析设计 1 总述 在语法分析阶段，根据词法分析程序识别出的Token单词，根据SysY语法规则识别出各种语法元素。采用递归下降法对语法中定义的语法成分进行分析。注意要消除左递归，以及面对可能的回溯问题进行预读。\n从**CompUnit**开始逐层往下进行分析。\n2 具体实现 设置getWordMove(),getNowWord(),getNextWord(),getThirdWord()工具函数用于读入tokenWord,同时设置GrammarString,curTokenWord等全局变量，用于存储获得的语法分析成分，以及当前所读到的tokenWord。\n对于普通的语法成分，我逐个读入tokenWord，然后对其进行常规的分析。\n对于表达式Expression，我首先扫描出整个的Expression,然后对于具有左递归性的语法规则，再依据特定的分隔符，对整个大的Expression进行分割成若干个较短的Expression，然后依次调用对应子表达式的分析方法，进行递归下降法进行分析。\n构建了一个新的Expressions类，用于存放分割出的子表达式,其中记录有分隔符，分割出的子表达式\npublic class Expressions { private ArrayList\u0026lt;TokenWord\u0026gt; symbols; private ArrayList\u0026lt;ArrayList\u0026lt;TokenWord\u0026gt;\u0026gt; expressions; public ArrayList\u0026lt;ArrayList\u0026lt;TokenWord\u0026gt;\u0026gt; getExpressions() { return expressions; } public ArrayList\u0026lt;TokenWord\u0026gt; getSymbols() { return symbols; } public Expressions(ArrayList\u0026lt;TokenWord\u0026gt; symbols, ArrayList\u0026lt;ArrayList\u0026lt;TokenWord\u0026gt;\u0026gt; expressions) { this.symbols = symbols; this.expressions = expressions; } } 2.1 获取表达式\u0026ndash;getExpression 通过一些特定的判断条件，结合当前字符以及前一个字符的值进行判断，以及是否位于函数的判断等，进行表达式的获取（后续改写的时候比较繁琐）\npublic ArrayList\u0026lt;TokenWord\u0026gt; getExpression() { TokenWord preWord = null; TokenWord word = getNowWord(); ArrayList\u0026lt;TokenWord\u0026gt; exp = new ArrayList\u0026lt;\u0026gt;(); boolean inFunc = false; int FuncFlag = 0; int FlagSmall = 0; int FlagBig = 0; while (true) { if (word.ClassCodeOf(\u0026#34;SEMICN\u0026#34;) || word.ClassCodeOf(\u0026#34;ASSIGN\u0026#34;) || word.ClassCodeOf(\u0026#34;RBRACE\u0026#34;) || word.ClassCodeOfTrueStmt()) { break; } //不在函数声明或者引用内，且遇到\u0026#39;,\u0026#39; if (word.ClassCodeOf(\u0026#34;COMMA\u0026#34;) \u0026amp;\u0026amp; !inFunc) { break; } //单词不在表达式内 if (preWord != null) { if ((preWord.ClassCodeOf(\u0026#34;INTCON\u0026#34;) || preWord.ClassCodeOf(\u0026#34;IDENFR\u0026#34;)) \u0026amp;\u0026amp; (word.ClassCodeOf(\u0026#34;INTCON\u0026#34;) || word.ClassCodeOf(\u0026#34;IDENFR\u0026#34;))) { break; } if ((preWord.ClassCodeOf(\u0026#34;RPARENT\u0026#34;) || preWord.ClassCodeOf(\u0026#34;RBRACK\u0026#34;)) \u0026amp;\u0026amp; (word.ClassCodeOf(\u0026#34;INTCON\u0026#34;) || word.ClassCodeOf(\u0026#34;IDENFR\u0026#34;))) { break; } if (FlagSmall == 0 \u0026amp;\u0026amp; FlagBig == 0) { if (preWord.ClassCodeOf(\u0026#34;INTCON\u0026#34;) \u0026amp;\u0026amp; word.ClassCodeOf(\u0026#34;LBRACK\u0026#34;)) { break; } if (preWord.ClassCodeOf(\u0026#34;INTCON\u0026#34;) \u0026amp;\u0026amp; word.ClassCodeOf(\u0026#34;LBRACE\u0026#34;)) { break; } } } if (word.ClassCodeOfNotInExp()) { break; } //在函数内部 if (word.ClassCodeOf(\u0026#34;IDENFR\u0026#34;)) { if (getNextWord().ClassCodeOf(\u0026#34;LPARENT\u0026#34;)) { inFunc = true; } } //(),[]识别 if (word.ClassCodeOf(\u0026#34;LPARENT\u0026#34;)) { FlagSmall++; if (inFunc) { FuncFlag++; } } if (word.ClassCodeOf(\u0026#34;RPARENT\u0026#34;)) { FlagSmall--; if (inFunc) { FuncFlag--; if (FuncFlag == 0) { inFunc = false; } } } switch (word.getClassCode()) { case \u0026#34;LBRACK\u0026#34;: FlagBig++; break; case \u0026#34;RBRACK\u0026#34;: FlagBig--; break; } if (FlagSmall \u0026lt; 0) { break; } if (FlagBig \u0026lt; 0) { break; } curTokenWord = tokenWords.get(cursor); cursor++; exp.add(curTokenWord); preWord = word; word = getNowWord(); } return exp; } 2.2 递归下降 对于一条语法推导规则，若其推导出的式子中含有$V_{N}$,那么考虑采用递归下降分析法\n在我的实现中，我每读一个tokenWord，检查它属于哪一个$V_{N}$，然后进入下一个相应的分析函数。\n例如CompUnit:\nCompUnit → {Decl} {FuncDef} MainFuncDef // 1.是否存在Decl 2.是否存在 FuncDef 具体实现：\npublic void analyseCompUnit() { TokenWord word = getNowWord(); while (word.ClassCodeOf(\u0026#34;CONSTTK\u0026#34;) || (word.ClassCodeOf(\u0026#34;INTTK\u0026#34;) \u0026amp;\u0026amp; getNextWord().ClassCodeOf(\u0026#34;IDENFR\u0026#34;) \u0026amp;\u0026amp; !getThirdWord().ClassCodeOf(\u0026#34;LPARENT\u0026#34;))) { analyseDecl(); word = getNowWord(); } while (word.ClassCodeOf(\u0026#34;VOIDTK\u0026#34;) || ((word.ClassCodeOf(\u0026#34;INTTK\u0026#34;) \u0026amp;\u0026amp; !getNextWord().ClassCodeOf(\u0026#34;MAINTK\u0026#34;)))) { analyseFuncDef(); word = getNowWord(); } if (word.ClassCodeOf(\u0026#34;INTTK\u0026#34;) \u0026amp;\u0026amp; getNextWord().ClassCodeOf(\u0026#34;MAINTK\u0026#34;)) { analyseMainFuncDef(); } else { Error(); } GrammarString.add(\u0026#34;\u0026lt;CompUnit\u0026gt;\u0026#34;); } 又比如Stmt\n语句 Stmt → LVal \u0026#39;=\u0026#39; Exp \u0026#39;;\u0026#39; // 每种类型的语句都要覆盖 | [Exp] \u0026#39;;\u0026#39; //有无Exp两种情况 | Block | \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Cond \u0026#39;)\u0026#39; Stmt [ \u0026#39;else\u0026#39; Stmt ] // 1.有else 2.无else | \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Cond \u0026#39;)\u0026#39; Stmt | \u0026#39;break\u0026#39; \u0026#39;;\u0026#39; | \u0026#39;continue\u0026#39; \u0026#39;;\u0026#39; | \u0026#39;return\u0026#39; [Exp] \u0026#39;;\u0026#39; // 1.有Exp 2.无Exp | LVal \u0026#39;=\u0026#39; \u0026#39;getint\u0026#39;\u0026#39;(\u0026#39;\u0026#39;)\u0026#39;\u0026#39;;\u0026#39; | \u0026#39;printf\u0026#39;\u0026#39;(\u0026#39;FormatString{\u0026#39;,\u0026#39;Exp}\u0026#39;)\u0026#39;\u0026#39;;\u0026#39; // 1.有Exp 2.无Exp 具体实现：\npublic void analyseStmt() { TokenWord word = getNowWord(); if (word.ClassCodeOf(\u0026#34;IDENFR\u0026#34;)) { ArrayList\u0026lt;TokenWord\u0026gt; exp = getExpression(); if (!getNowWord().ClassCodeOf(\u0026#34;SEMICN\u0026#34;)) { analyseLVal(exp); getWordMove();//= if (getNowWord().ClassCodeOf(\u0026#34;GETINTTK\u0026#34;)) { getWordMove();//getint getWordMove();//( getWordMove();//) getWordMove();//; } else { analyseExp(getExpression());// getWordMove(); //; } } else { analyseExp(exp); getWordMove();//; } } else if (word.ClassCodeOfBeginOfExp()) { analyseExp(getExpression()); getWordMove();//; } else if (word.ClassCodeOf(\u0026#34;LBRACE\u0026#34;)) { analyseBlock(); } else if (word.ClassCodeOf(\u0026#34;IFTK\u0026#34;)) { getWordMove();//if getWordMove();//( analyseCond(); getWordMove();//) analyseStmt(); word = getNowWord(); if (word.ClassCodeOf(\u0026#34;ELSETK\u0026#34;)) { getWordMove(); //else analyseStmt(); } } else if (word.ClassCodeOf(\u0026#34;WHILETK\u0026#34;)) { getWordMove();//while getWordMove();//( analyseCond(); getWordMove();//) analyseStmt(); } else if (word.ClassCodeOf(\u0026#34;BREAKTK\u0026#34;)) { getWordMove();//break getWordMove();//; } else if (word.ClassCodeOf(\u0026#34;CONTINUETK\u0026#34;)) { getWordMove();//continue getWordMove();//; } else if (word.ClassCodeOf(\u0026#34;RETURNTK\u0026#34;)) { getWordMove();//return word = getNowWord(); if (word.ClassCodeOfBeginOfExp()) { analyseExp(getExpression()); } getWordMove();//; } else if (word.ClassCodeOf(\u0026#34;PRINTFTK\u0026#34;)) { getWordMove();//printf getWordMove();//( getWordMove();//STRCON word = getNowWord(); while (word.ClassCodeOf(\u0026#34;COMMA\u0026#34;)) { getWordMove();//, analyseExp(getExpression()); word = getNowWord(); } getWordMove();//) getWordMove();//; } else if (word.ClassCodeOf(\u0026#34;SEMICN\u0026#34;)) { getWordMove();//; } GrammarString.add(\u0026#34;\u0026lt;Stmt\u0026gt;\u0026#34;); } 在以上的分析过程中，需要注意的是\n一些语法成分内部分析过程的细节性注意（括号匹配等问题） 面对$V_{N}$，需要getNowWord()预读，但是不能直接加入GrammarString中，需要进一步判断属于哪个$V_{N}$ 2.3 左递归消除 采用转换为BNF范式的方法消除左递归\n例如加减表达式\nAddExp → MulExp | AddExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 改写为\nAddExp → MulExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp (\u0026#39;+\u0026#39; | \u0026#39;−\u0026#39;) MulExp ... 改写完以后，构造**divideExp()**方法，将整个大的表达式进行分割，再依次调用子程序进行分析\nprivate Expressions (divideExp(ArrayList\u0026lt;TokenWord\u0026gt; exp, ArrayList\u0026lt;String\u0026gt; symbol):\n输入：表达式exp,分隔符列表\n返回：分割出的子表达式，分割符号列表 ———— return new Expressions(symbols, exps)\npublic Expressions divideExp(ArrayList\u0026lt;TokenWord\u0026gt; exp, ArrayList\u0026lt;String\u0026gt; symbol) { ArrayList\u0026lt;ArrayList\u0026lt;TokenWord\u0026gt;\u0026gt; exps = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;TokenWord\u0026gt; tmpExp = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;TokenWord\u0026gt; symbols = new ArrayList\u0026lt;\u0026gt;(); boolean unaryFlag = false; int FlagSmall = 0; int FlagBig = 0; for (TokenWord word : exp) { switch (word.getClassCode()) { case \u0026#34;LPARENT\u0026#34;: FlagSmall++; break; case \u0026#34;RPARENT\u0026#34;: FlagSmall--; break; case \u0026#34;LBRACK\u0026#34;: FlagBig++; break; case \u0026#34;RBRACK\u0026#34;: FlagBig--; break; } //遇到指定分隔符，并且(),[]得到匹配 if (symbol.contains(word.getClassCode()) \u0026amp;\u0026amp; FlagSmall == 0 \u0026amp;\u0026amp; FlagBig == 0) { //如果分隔符是单目运算符 if (word.ClassCodeOfUnary()) { //如果上一个word不是识别符,),],int常数，那么不在此处分割，仅将当前word加入exp if (!unaryFlag) { tmpExp.add(word); continue; } } //如果上一个word不是识别符,),],int常数，向exps中加入当前表达式，并且重置表达式，向分隔符列表中加入当前word exps.add(tmpExp); symbols.add(word); tmpExp = new ArrayList\u0026lt;\u0026gt;(); } else { tmpExp.add(word); } unaryFlag = word.ClassCodeOf(\u0026#34;IDENFR\u0026#34;) || word.ClassCodeOf(\u0026#34;RPARENT\u0026#34;) || word.ClassCodeOf(\u0026#34;INTCON\u0026#34;) || word.ClassCodeOf(\u0026#34;RBRACK\u0026#34;); } exps.add(tmpExp); return new Expressions(symbols, exps); } 最终例如加减表达式,分析代码如下\npublic void analyseAddExp(ArrayList\u0026lt;TokenWord\u0026gt; exp) { Expressions exps = divideExp(exp, new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;PLUS\u0026#34;, \u0026#34;MINU\u0026#34;))); int j = 0; for (ArrayList\u0026lt;TokenWord\u0026gt; tmpExp : exps.getExpressions()) { analyseMulExp(tmpExp); GrammarString.add(\u0026#34;\u0026lt;AddExp\u0026gt;\u0026#34;); if (j \u0026lt; exps.getSymbols().size()) { GrammarString.add(exps.getSymbols().get(j++).toString()); } } } 五. 错误处理设计 1 总体设计 新定义类\n定义Error类，存放错误的类型，所在行数 定义Symbol类，type是指符号的类型,例如const,var,para。Dimension是一个整数,指出了符号的维数。如果为0，则符号为int。如果为1，则符号为int[]；如果为2，则符号为int[][]\u0026hellip;。token是指Symbol的内容。layer就是这个符号所在的层级。 public Symbol(String type, int Dimension, TokenWord tokenWord, int layer) { this.type = type; this.Dimension = Dimension; this.token = tokenWord.getToken(); this.layer = layer; } 定义SymbolTable类来存放符号表，在其中用HashMap\u0026lt;String, Symbol\u0026gt; mapSymbol来存放符号，同时在其中定义了一些基础的方法\n定义Func类，分别记录函数名、函数返回类型（void，int）、以及函数的参数类型\n用ArrayList\u0026lt;Integer\u0026gt; TypeOfParas来记录函数的参数类型，0、1、2分别代表着int,int[],int[][]\nType Example Integer Void （函数返回值为空） -1 Int a 0 Int[] a[] 1 Int[] [] a[] [3] 2 在GrammarAnalysis类中，我定义了如下几个新的变量\nprivate final ArrayList\u0026lt;Error\u0026gt; errors = new ArrayList\u0026lt;\u0026gt;(); //函数名Hashmap private final HashMap\u0026lt;String, Func\u0026gt; funcs = new HashMap\u0026lt;\u0026gt;(); //层级layer对应符号表,每当进入一个新层级，就将layer++，新构造一个SymbolTables private final HashMap\u0026lt;Integer, SymbolTable\u0026gt; SymbolTables = new HashMap\u0026lt;\u0026gt;(); private int layer = -1; private boolean ReturnFlag = false;//表示当前函数是否需要返回。 private int IndexWhile = 0; //表示当前代码块是否在while中。 注意：\n在AnalyseBlock中对于一个自定义函数，与函数的参数是同一个Layer的（否则无法判断函数内部重复定义函数参数等错误）而对于main函数，进入到Block的时候，Layer要加1（main函数内部可以重复定义全局变量）\nprivate boolean analyseBlock(boolean fromFunc) { ... if (!fromFunc) { IncreaseLayer(); } ... if (!fromFunc) { DecreaseLayer(); } } 2 具体分析 Errors a 检查格式就好\npublic boolean IllegalFormatString() { int i = 1; while (i \u0026lt;= content.length() - 2) { if (NormalChar(content.charAt(i))) { if (content.charAt(i) == \u0026#39;\\\\\u0026#39;) { if (content.charAt(i + 1) != \u0026#39;n\u0026#39;) { return true; } } i++; } else { if (content.charAt(i) == \u0026#39;%\u0026#39; \u0026amp;\u0026amp; content.charAt(i + 1) == \u0026#39;d\u0026#39;) { i++; } else { return true; } } } return false; } b c b: 对于变量、函数参数来说，每次我得到一个Ident识别符，检查是否有相同的符号被定义在同一层级。对于函数来说，直接查看funcs.containsKey(curTokenWord.getToken())。\n//判断当前区块是否有当前符号 b public boolean existSymbolInThisArea(TokenWord tokenWord) { return SymbolTables.get(layer).SymbolExist(tokenWord); } c: 检查所有层级的符号表，此函数符号是否已定义。函数直接查看funcs\nprivate boolean hasSymbol(Word word) { for (Symbols s : symbols.values()) { if (s.hasSymbol(word)) { return true; } } return false; } d e 首先，为了获取每一个函数参数（可能为表达式）的真实维数，我在语法分析器的递归下降过程中，按照Exp-\u0026gt;Add-\u0026gt;Mul-\u0026gt;Unary-\u0026gt;Primary/Func-\u0026gt;Lval/Exp这个路径，每个分析函数分别返回维数（调用下一层获得），直到Lval。\npublic int analyseExp(ArrayList\u0026lt;TokenWord\u0026gt; exp) { int Dimension = analyseAddExp(exp); GrammarString.add(\u0026#34;\u0026lt;Exp\u0026gt;\u0026#34;); return Dimension; } 在Lval中，结束递归调用，返回最终结果\n注意\n例如a[3][5],lval对应a[3],那么实际数组维数是1 考虑到a[b[3]]\nprivate int analyseLVal(ArrayList\u0026lt;Word\u0026gt; exp) { TokenWord Ident = exp.get(0); if (!existSymbol(Ident)) { Error(\u0026#34;c\u0026#34;, Ident.getLineNum()); } GrammarString.add(Ident.toString());//Ident //若是数组\tif (exp.size() \u0026gt; 1) { ArrayList\u0026lt;TokenWord\u0026gt; tmpExp = new ArrayList\u0026lt;\u0026gt;(); int flag = 0; //逐个扫描 for (int i = 1; i \u0026lt; exp.size(); i++) { TokenWord word = exp.get(i); if (word.ClassCodeOf(\u0026#34;LBRACK\u0026#34;)) { if (flag == 0) { Dimension++; //a[]这种，而不是a[[]](不能加维数) } flag++; if (flag == 1) { GrammarString.add(word.toString()); tmpExp = new ArrayList\u0026lt;\u0026gt;(); } else { tmpExp.add(word); } } else if (word.ClassCodeOf(\u0026#34;RBRACK\u0026#34;)) { flag--; if (flag == 0) { analyseExp(tmpExp); GrammarString.add(word.toString()); } else { tmpExp.add(word); } } else { tmpExp.add(word); } } if (flag \u0026gt; 0) { analyseExp(tmpExp); Error(\u0026#34;k\u0026#34;, exp.get(exp.size() - 1).getLineNum()); // not sure } } GrammarString.add(\u0026#34;\u0026lt;LVal\u0026gt;\u0026#34;); //如上注意 if (existSymbol(Ident)) { return getSymbol(Ident).getDimension() - Dimension; } else { return 0; } } 定义checkFuncParas函数来进行参数数目，参数维数判断,在分析analyseFuncRParams时进行调用\n//检查函数参数匹配问题 private void checkFuncParas(TokenWord funcName, ArrayList\u0026lt;Integer\u0026gt; standardTypeOfParas, ArrayList\u0026lt;Integer\u0026gt; nowTypeOfParas) { if (standardTypeOfParas.size() != nowTypeOfParas.size()) { Error(\u0026#34;d\u0026#34;, funcName.getLineNum()); } else { for (int i = 0; i \u0026lt; standardTypeOfParas.size(); i++) { if (!Objects.equals(standardTypeOfParas.get(i), nowTypeOfParas.get(i))) { Error(\u0026#34;e\u0026#34;, funcName.getLineNum()); } } } } public void analyseFuncRParams(ArrayList\u0026lt;TokenWord\u0026gt; exp, TokenWord Ident, ArrayList\u0026lt;Integer\u0026gt; TypeOfParas) { ArrayList\u0026lt;Integer\u0026gt; nowParas = new ArrayList\u0026lt;\u0026gt;(); Expressions exps = divideExp(exp, new ArrayList\u0026lt;\u0026gt;(Collections.singletonList(\u0026#34;COMMA\u0026#34;))); int j = 0; for (ArrayList\u0026lt;TokenWord\u0026gt; tmpExp : exps.getExpressions()) { int Dimension = analyseExp(tmpExp); nowParas.add(Dimension); if (j \u0026lt; exps.getSymbols().size()) { GrammarString.add(exps.getSymbols().get(j++).toString()); } } if (TypeOfParas != null) { checkFuncParas(Ident, TypeOfParas, nowParas); } GrammarString.add(\u0026#34;\u0026lt;FuncRParams\u0026gt;\u0026#34;); } 然后在analyseFuncRParams时，如果遇到了函数调用那么进行判断\nif (exp.size() \u0026gt; 3) { //实参列表有东西 analyseFuncRParams(new ArrayList\u0026lt;\u0026gt;(exp.subList(2, exp.size() - 1)), Ident, TypeOfParas); } else { //实参列表没东西 if (TypeOfParas != null) { if (TypeOfParas.size() != 0) { Error(\u0026#34;d\u0026#34;, Ident.getLineNum()); } } } f g 如果当前函数需要返回，会有一个全局变量 ReturnFlag来显示，初始化为false。其在analyseFuncDef()以及analyseMainFuncDef()中，得到赋值。\n对于f\n在分析Stmt中的RETURNTK时候，若 ReturnFlag为false,那么就产生**f**错误\n对于g\n定义了hasReturn变量，其在analyseBlock→BlockItem/Stmt→Stmt这条路径上进行调用传递，并作为返回值返回\n然后在analyseFuncDef()以及analyseMainFuncDef()中对ReturnFlag \u0026amp;\u0026amp; !hasReturn进行判断，若是真则产生**g**错误\nh 判断是否为常数即可\nif (isConst(word)) { Error(\u0026#34;h\u0026#34;, word.getLineNum()); } i j k 定义函数来检查，以）为例\n//检查右小括号 public void checkRightParent() { if (getNowWord().getClassCode().equals(\u0026#34;RPARENT\u0026#34;)) { getWordMove(); } else { Error(\u0026#34;j\u0026#34;, curTokenWord.getLineNum()); } } l 分析Stmt遇到PRINTFTK时，判断一下printf里面逗号的数量和STRCON中的要求输出数是否一致即可\nm 如果代码块在While循环中，则有一个全局变量WhileFlag表示,其值不为0。在遇到break或是continue的时候判断一下即可\n六. 生成代码设计 在这一部分中，我选择生成pcode代码。我设计了一种基于逆波兰表达式堆栈和符号表的虚拟Pcode代码,在进行语法分析的过程中，随之生成Pcode代码。 同时，我设计了执行它们的虚拟机。Pcode虚拟机是用于运行Pcode命令的虚构机器。 它由一个代码区(pcodes)、一个指令指针(EIP)、一个main函数指针(mainAddress）、一个堆栈（存放各种数值）、存放返回信息的数组、一个变量表var_table,一个函数表func_table和一个标签表label_table组成。\n在接下来的文章中，我将首先介绍如何生成pcode，然后介绍pcode如何执行。\n编码前设计 如何生成Pcode 新增的类 在PcodeGeneration包中，我新增了\nFunction类————记录函数声明在Pcodes代码中的位置以及其参数数量\npublic Function(int index, int argsNum) { this.StackOffset = index; this.ParamsNum = argsNum; } LabelCreator类————用于产生标签\nVariety类————记录变量在栈上的位置，维度数，各维数的数量\nRetInfo类————记录函数的返回地址（调用函数指令的下一条指令的EIP），调用函数前栈上的末尾位置（stack.size() - 1），虚拟机中当前的变量表（var_table），函数的参数数量，函数所需调用的参数数量，目前已有的参数数量\npublic RetInfo(int eip, int stackPtr, HashMap\u0026lt;String, Variety\u0026gt; varTable, int paramsNum, int callArgsNum, int nowArgsNum) { this.eip = eip; this.stackPtr = stackPtr; this.varTable = varTable; this.paramsNum = paramsNum; this.callParamsNum = callArgsNum; this.nowParamsNum = nowArgsNum; } Pcode类————记录一个Pcode指令的名称key,FirstValue,LastValue(如有)，同时规定了Pcode的规范化输出（label,func,call,print进行特殊考虑)\n@Override public String toString() { String first = \u0026#34;\u0026#34;; String second = \u0026#34;\u0026#34;; if (key.equals(PcodeKey.label)) { return FirstValue.toString() + \u0026#34;: \u0026#34;; } if (key.equals(PcodeKey.func)) { return \u0026#34;FUNC @\u0026#34; + FirstValue.toString() + \u0026#34;:\u0026#34;; } if (key.equals(PcodeKey.call)) { return \u0026#34;$\u0026#34; + FirstValue.toString(); } if (key.equals(PcodeKey.print)) { return key + \u0026#34; \u0026#34; + FirstValue; } if (FirstValue == null) { first = \u0026#34;\u0026#34;; } else { first = FirstValue.toString(); } if (SecondValue == null) { second = \u0026#34;\u0026#34;; } else { second = \u0026#34;, \u0026#34; + SecondValue.toString(); } return key + \u0026#34; \u0026#34; + first + second; } PcodeKey枚举类，存放Pcode的基本指令名称,后面会详细介绍\n变量声明 如何区分不同的变量 根据唯一的作用域号区分不同作用域的变量，如：CurLayerId + \u0026quot;_\u0026quot; + Ident.getToken()。在这种情况下，除了递归函数调用以外，代码中不会多次重复出现该变量，可以通过将varTable到堆栈来解决。\n不区分const和var。\n非数组变量：新建一个变量var并让它指向堆栈顶部。如果它有初始化，push初始化的值进入堆栈（如果int x=q这种初始化，那么需要push q，然后再getvalue）。如果未初始化，则添加一个defaultvalue命令来将变量的默认初始值(我将其推入0)推送到堆栈。 数组变量：新建一个变量var并让它指向堆栈顶部。然后push其各维的维数，然后用dimarrayvar命令表示他是数组,如果它有初始化，依次push初始化的值进入堆栈。如果未初始化，则添加一个defaultvalue命令来将变量的默认初始值(我将其推入0)推送到堆栈。 如果是getint，那么加入getint eg：int x[1][3];\nvar 1_x push 1 push 3 dimarrayvar 1_x, 2 defaultvalue 1_x, 2 赋值语句 首先push待赋值的变量（若是数组，还需要push偏移量），然后利用getaddress计算并将变量的地址推送到堆栈顶部。然后分析赋值语句右侧的表达式，对于数值，直接push,对于表达式，利用getvalue获取表达式的值。（若是算术运算表达式，就先执行）在此之后，堆栈中有两个数字，即地址和值。利用pop将该值分配给该地址。\n变量取值 例如要取得x[0][2]的值\npush 2_x push 0 push 2 getvalue 2_x, 0 函数定义 直接Pcodes.add(new Pcode(PcodeKey.func, curTokenWord.getToken()));（mainfunc特殊定义）\n函数形参 fparam+名字+维数\n注意：若是数组，需要先push进去各维数量（二维形参，只需要push第二维数量）\n函数调用 实参类型\n数值：先push函数实参，再rparam+函数实参名字+维数,再call相应函数名\n变量：先push变量名\n若是数组，就getaddress加维数\n若是普通变量，就getvalue+维数；若是a[1][3]这种，就先push进去1,3，再getvalue\n剩下的操作同上\n函数返回 ret 0代表无返回值\nret 1代表有返回值，在ret之前会有push（由分析表达式产生）之类的，代表返回指的具体数值\n打印语句 Pcodes.add(new Pcode(PcodeKey.print, STRCON.getToken(), OutputNum)); 注意：打印变量，则按照老套路，先push变量，再getvalue例如printf(\u0026quot;%d\u0026quot;,x);，则是push 2_x , getvalue 2_x, 0 print \u0026quot;%d\u0026quot;\n条件跳转控制语句 首先，我定义了三个ArrayList,分别存放着对应标签的HashMap\nprivate ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt; If_Labels = new ArrayList\u0026lt;\u0026gt;(); private ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt; While_Labels = new ArrayList\u0026lt;\u0026gt;(); private ArrayList\u0026lt;HashMap\u0026lt;Integer, String\u0026gt;\u0026gt; Cond_Labels = new ArrayList\u0026lt;\u0026gt;(); 每当遇到IFTK或其他判断语句时，生成相应标签\npublic void getNewIfLabel() { HashMap\u0026lt;String, String\u0026gt; tmpIfLabel = new HashMap\u0026lt;\u0026gt;(); tmpIfLabel.put(\u0026#34;if\u0026#34;, LabelCreator.CreateLabel(\u0026#34;if\u0026#34;)); tmpIfLabel.put(\u0026#34;else\u0026#34;, LabelCreator.CreateLabel(\u0026#34;else\u0026#34;)); tmpIfLabel.put(\u0026#34;endif\u0026#34;, LabelCreator.CreateLabel(\u0026#34;endif\u0026#34;)); tmpIfLabel.put(\u0026#34;ifblock\u0026#34;, LabelCreator.CreateLabel(\u0026#34;ifblock\u0026#34;)); If_Labels.add(tmpIfLabel); } 以if为例子\nif (word.ClassCodeOf(\u0026#34;IFTK\u0026#34;)) { getNewIfLabel(); Pcodes.add(new Pcode(PcodeKey.label, If_Labels.get(If_Labels.size() - 1).get(\u0026#34;if\u0026#34;))); getWordMove();//if getWordMove();//( analyseCond(\u0026#34;if\u0026#34;); checkRightParent(); Pcodes.add(new Pcode(PcodeKey.jz, If_Labels.get(If_Labels.size() - 1).get(\u0026#34;else\u0026#34;))); Pcodes.add(new Pcode(PcodeKey.label, If_Labels.get(If_Labels.size() - 1).get(\u0026#34;ifblock\u0026#34;))); analyseStmt(); word = getNowWord(); Pcodes.add(new Pcode(PcodeKey.jmp, If_Labels.get(If_Labels.size() - 1).get(\u0026#34;endif\u0026#34;))); Pcodes.add(new Pcode(PcodeKey.label, If_Labels.get(If_Labels.size() - 1).get(\u0026#34;else\u0026#34;))); if (word.ClassCodeOf(\u0026#34;ELSETK\u0026#34;)) { getWordMove(); //else analyseStmt(); } Pcodes.add(new Pcode(PcodeKey.label, If_Labels.get(If_Labels.size() - 1).get(\u0026#34;endif\u0026#34;))); If_Labels.remove(If_Labels.size() - 1); } while\nif (word.ClassCodeOf(\u0026#34;WHILETK\u0026#34;)) { getNewWhileLabel(); Pcodes.add(new Pcode(PcodeKey.label, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;while\u0026#34;))); getWordMove();//while IndexWhile++; getWordMove();//( analyseCond(\u0026#34;while\u0026#34;); checkRightParent(); Pcodes.add(new Pcode(PcodeKey.jz, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;endwhile\u0026#34;))); Pcodes.add(new Pcode(PcodeKey.label, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;whileblock\u0026#34;))); analyseStmt(); IndexWhile--; Pcodes.add(new Pcode(PcodeKey.jmp, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;while\u0026#34;))); Pcodes.add(new Pcode(PcodeKey.label, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;endwhile\u0026#34;))); While_Labels.remove(While_Labels.size() - 1); }//break else if (word.ClassCodeOf(\u0026#34;BREAKTK\u0026#34;)) { getWordMove();//break if (IndexWhile == 0) { Error(\u0026#34;m\u0026#34;, curTokenWord.getLineNum()); } checkSemicn(); Pcodes.add(new Pcode(PcodeKey.jmp, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;endwhile\u0026#34;))); }//continue else if (word.ClassCodeOf(\u0026#34;CONTINUETK\u0026#34;)) { getWordMove();//continue if (IndexWhile == 0) { Error(\u0026#34;m\u0026#34;, curTokenWord.getLineNum()); } checkSemicn(); Pcodes.add(new Pcode(PcodeKey.jmp, While_Labels.get(While_Labels.size() - 1).get(\u0026#34;while\u0026#34;))); } 加减、乘除，比较运算表达式 以比较为例\npublic void analyseRelExp(ArrayList\u0026lt;TokenWord\u0026gt; exp) { Expressions exps = divideExp(exp, new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;LSS\u0026#34;, \u0026#34;LEQ\u0026#34;, \u0026#34;GRE\u0026#34;, \u0026#34;GEQ\u0026#34;))); int j = 0; for (ArrayList\u0026lt;TokenWord\u0026gt; tmpExp : exps.getExpressions()) { analyseAddExp(tmpExp); if (j \u0026gt; 0 \u0026amp;\u0026amp; j \u0026lt;= exps.getExpressions().size()) { if (exps.getSymbols().get(j - 1).ClassCodeOf(\u0026#34;LSS\u0026#34;)) { Pcodes.add(new Pcode(PcodeKey.cmplt)); } else if (exps.getSymbols().get(j - 1).ClassCodeOf(\u0026#34;LEQ\u0026#34;)) { Pcodes.add(new Pcode(PcodeKey.cmple)); } else if (exps.getSymbols().get(j - 1).ClassCodeOf(\u0026#34;GRE\u0026#34;)) { Pcodes.add(new Pcode(PcodeKey.cmpgt)); } else if (exps.getSymbols().get(j - 1).ClassCodeOf(\u0026#34;GEQ\u0026#34;)) { Pcodes.add(new Pcode(PcodeKey.cmpge)); } } GrammarString.add(\u0026#34;\u0026lt;RelExp\u0026gt;\u0026#34;); if (j \u0026lt; exps.getSymbols().size()) { GrammarString.add(exps.getSymbols().get(j++).toString()); } } } 需要注意的是，由于采用逆波兰表达式，当分析到第二个表达式的时候，其实j已经跳到第二个表达式后面了，所以需要判断的是j-1位置处\n如何运行Pcode Pcode虚拟机是用于运行Pcode命令的虚构机器。 它由一个代码区(pcodes)、一个指令指针(EIP)、一个main函数指针(mainAddress）、一个堆栈（存放各种数值）、存放返回信息的数组、一个变量表var_table,一个函数表func_table和一个标签表label_table组成。\n我定义了一个PcodeExecutor类，对应着我的Pcode虚拟机\nprivate int eip = 0; //mainAddress标记main函数的地址 private int mainAddress; private Scanner scanner; private ArrayList\u0026lt;Pcode\u0026gt; pcodes; private ArrayList\u0026lt;RetInfo\u0026gt; retInfos = new ArrayList\u0026lt;\u0026gt;(); //模拟存放各种数值的栈 private ArrayList\u0026lt;Integer\u0026gt; stack = new ArrayList\u0026lt;\u0026gt;(); private HashMap\u0026lt;String, Variety\u0026gt; varTable = new HashMap\u0026lt;\u0026gt;(); private HashMap\u0026lt;String, Function\u0026gt; funcTable = new HashMap\u0026lt;\u0026gt;(); //label对应的代码行数(eip) private HashMap\u0026lt;String, Integer\u0026gt; labelTable = new HashMap\u0026lt;\u0026gt;(); 初始化 将scanner和pcode代码初始化，同时扫描Pcode代码,将扫描到的标签(名称，位置）加入标签表，函数（名称，function）加入函数表，\npublic PcodeExecutor(ArrayList\u0026lt;Pcode\u0026gt; pcodes, Scanner sc) { this.pcodes = pcodes; this.scanner = sc; int index = 0; while (index \u0026lt; pcodes.size()) { Pcode pcode = pcodes.get(index); switch (pcode.getKey()) { case label: labelTable.put(pcode.getFirstValue().toString(), index); break; case func: funcTable.put(pcode.getFirstValue().toString(), new Function(index, (int) pcode.getSecondValue())); break; case mainfunc: mainAddress = index; break; } index++; } } 基本操作 获取变量 如果当前变量表中存在该变量，则直接返回，否则在全局变量中寻找\nprivate Variety getVar(String varName) { if (varTable.containsKey(varName)) { return varTable.get(varName); } else { //全局变量 return retInfos.get(0).getVarTable().get(varName); } } push、pop private void push(int value) { stack.add(value); } //弹出并返回 private int pop() { int value = stack.get(stack.size() - 1); stack.remove(stack.size() - 1); return value; } 获取变量在栈上的绝对地址 注意这里的维数是相对的 for example, to int a[3][2] ,a[0][0] is 0, a[0] is 1, a is 2 a[3][2],SecondDim:2;FirstDim:3\nprivate int getAddress(Variety var, int Dimension) { int Address = 0; int n = var.getDimension() - Dimension; if (n == 0) { Address = var.getOffset(); } if (n == 1) { int i = pop(); if (var.getDimension() == 1) { Address = var.getOffset() + i; } else { Address = var.getOffset() + i * var.getSecondDimNum(); } } if (n == 2) { int i = pop(); int j = pop(); Address = var.getOffset() + j * var.getSecondDimNum() + i; } return Address; } 运行代码 首先定义几个变量\n//已经存在的参数数量 int ExistParamsNum = 0; //调用所需的参数数量 int CallParamsNum = 0; boolean MainFuncFlag = false; //函数实参对应的栈上的地址列表 ArrayList\u0026lt;Integer\u0026gt; rparams = new ArrayList\u0026lt;\u0026gt;(); var 产生新的变量，置于stack末尾，放进变量表\ncase var: { Variety var = new Variety(stack.size()); varTable.put((String) pcode.getFirstValue(), var); } push //对于数字的话，push进栈里 case push: { if (pcode.getFirstValue() instanceof Integer) { push((int) pcode.getFirstValue()); } } pop pop操作:*value1 = value2 在我的定义中，我会在变量赋值以前依次将其在栈中对应的地址以及所赋的值压进栈中\ncase pop: { int value = pop(); int address = pop(); stack.set(address, value); } 计算 Calculation Type\nTwo operators:\nint b = pop(); int a = pop(); push(cal(a,b)); Single operator:\npush(cal(pop())); 数组维数 声明变量维数,紧跟着的是维数\ncase dimarrayvar: { Variety var = getVar((String) pcode.getFirstValue()); int dimension = (int) pcode.getSecondValue(); var.setDimension(dimension); if (dimension == 2) { var.setSecondDimNum(pop()); var.setFirstDimNum(pop()); } if (dimension == 1) { var.setFirstDimNum(pop()); } } 占位符 case defaultvalue: { Variety var = getVar((String) pcode.getFirstValue()); int dimension = (int) pcode.getSecondValue(); if (dimension == 0) { push(0); } if (dimension == 1) { for (int i = 0; i \u0026lt; var.getFirstDimNum(); i++) { push(0); } } if (dimension == 2) { for (int i = 0; i \u0026lt; var.getFirstDimNum() * var.getSecondDimNum(); i++) { push(0); } } } getint 读取int\ncase getint: { int value = scanner.nextInt(); push(value); } 跳转 如果是条件跳转，取出stack中最后一个值判断\n函数定义 main函数\ncase mainfunc: { MainFuncFlag = true; //retInfos[0] storage 全局变量(varTable) retInfos.add(new RetInfo(pcodes.size(), stack.size() - 1, varTable, 0, 0, 0)); varTable = new HashMap\u0026lt;\u0026gt;(); } 自定义函数\n遇见func定义的话，均先进入到main函数中，等到调用的时候再跳转\ncase func: { int flag = MainFuncFlag ? 1 : 0; if (flag == 0) { eip = mainAddress - 1; } } 函数调用 总体上来说，就是遇到函数调用-\u0026gt;存实参数（值/地址）-\u0026gt;存下retInfo，产生新变量表（用于函数），跳转到定义处-\u0026gt;遇到形参，依次存入新变量表-\u0026gt;遇到ret，进行返回，将原retinfo还原\nFirst, before function call, there will be some parameters to be pushed into the stack. Each will be followed by a rparam command, which memorize the address of the previous variety.\n注意：对于传值实参，若是数组具体到某个数（本质是传具体值），对应操作先push各维度，再getvalue，若是具体数值，就是push数值，因此直接rparams.add(stack.size() - 1)。对于传地址参数，则是先push数组名，再getaddress，因此需要将其地址压入\ncase rparam: { int dimension = (int) pcode.getSecondValue(); if (dimension == 0) { //对于非数组的参数，直接将其值压入栈中 //因此其地址是栈顶的地址 rparams.add(stack.size() - 1); } else { //对于数组的参数，将其地址压入栈中 rparams.add(stack.get(stack.size() - 1)); } } Second, function CALL.\nMemorize the eip, stack top address, and information about the function(In fact, they will be pushed into stack too). Then update the varTable and eip. Ready for execute function.\ncase call: { Function func = funcTable.get((String) pcode.getFirstValue()); retInfos.add(new RetInfo(eip, stack.size() - 1, varTable, func.getParamsNum(), func.getParamsNum(), ExistParamsNum)); //跳转至函数定义处 eip = func.getOffset(); varTable = new HashMap\u0026lt;\u0026gt;(); CallParamsNum = func.getParamsNum(); ExistParamsNum = 0; } Finally, return when it\u0026rsquo;s RET\nRestore eip, varTable from RetInfo, clear the new information pushed when function in the stack.\ncase ret: { int type = (int) pcode.getFirstValue(); RetInfo retInfo = retInfos.remove(retInfos.size() - 1); eip = retInfo.getEip(); varTable = retInfo.getVarTable(); CallParamsNum = retInfo.getCallParamsNum(); ExistParamsNum = retInfo.getNowParamsNum(); if (type == 1) { //有返回值的话，由于之前将返回值压入栈中，故需要保留栈顶元素 stack.subList(retInfo.getStackPtr() + 1 - retInfo.getParamsNum(), stack.size() - 1).clear(); } else { stack.subList(retInfo.getStackPtr() + 1 - retInfo.getParamsNum(), stack.size()).clear(); } } Additional：\n储存完实参，调用函数以后跳转到函数定义的地方\nfparam:Firstvalue:Ident_name Secondvalue:Type/Dimension\ncase fparam: { //函数现在需要的形参的index int nowfparamIndex = rparams.size() - CallParamsNum + ExistParamsNum; int addressOnStack = rparams.get(nowfparamIndex); Variety fparam = new Variety(addressOnStack); int dimension = (int) pcode.getSecondValue(); fparam.setDimension(dimension); //二维数组需要将第二维大小作为参数传入 if (dimension == 2) { fparam.setSecondDimNum(pop()); } varTable.put((String) pcode.getFirstValue(), fparam); ExistParamsNum++; //如果形参已经全部生成，就清空rparams数组里对应的其形参 if (ExistParamsNum == CallParamsNum) { rparams.subList(rparams.size() - CallParamsNum, rparams.size()).clear(); } } break; 打印输出 print:Firstvalue:String Secondvalue:output num quantity\ncase print: { String str = (String) pcode.getFirstValue(); int num = (int) pcode.getSecondValue(); int q = num - 1; StringBuilder sb = new StringBuilder(); ArrayList\u0026lt;Integer\u0026gt; OutParams = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; num; i++) { OutParams.add(pop()); } for (int j = 0; j \u0026lt; str.length(); j++) { if (j \u0026lt; str.length() - 1) { if (str.charAt(j) == \u0026#39;%\u0026#39; \u0026amp;\u0026amp; str.charAt(j + 1) == \u0026#39;d\u0026#39;) { sb.append(OutParams.get(q--).toString()); j++; continue; } } sb.append(str.charAt(j)); } //除去引号 OutputString.add(sb.substring(1, sb.length() - 1)); } break; 获取变量的值，地址 Firstvalue:Ident_name Secondvalue:Dimension\ncase getvalue: { Variety var = getVar((String) pcode.getFirstValue()); int dimension = (int) pcode.getSecondValue(); int address = getAddress(var, dimension); push(stack.get(address)); } break; //获得变量在栈上的地址，给定变量名和维度 case getaddress: { Variety var = getVar((String) pcode.getFirstValue()); int dimension = (int) pcode.getSecondValue(); int address = getAddress(var, dimension); push(address); } break; 编码后设计 小细节问题 在GrammarAnalysis中，新增CurLayerId变量，注意和layer区分\n前者为了区分符号表内变量所处层级，因此不考虑出区块减一，而后者用来构造符号表的HashMap，有并列关系，所以出了区块就要减一\n两者每次新进入一个区块之后，都会加一\n但是退出一个区块的时候，前者不会减一，而后者依旧减一\npublic void addSymbol(TokenWord tokenWord, String type, int Dimension, int CurLayerId) { SymbolTables.get(layer).SymbolInsert(type, Dimension, tokenWord, CurLayerId); } Pcode代码对应表 Common Type CodeType Value1 Value2 Operation label label_name set a label var ident_name declare a variety push ident_name/digit push(value1) pop ident_name 在pop命令以前push进来的赋值语句右面的式子的值 *value1 = value2（这个value2指的是在pop命令以前push进来的赋值语句右面的式子的值） jz label_name jump if stack top is zero jnz label_name jump if stack top is not zero jmp label_name jump unconditionally main main function label func function label endfunc end of function label fparam ident_name dimension/type 函数形参parameters ret return value or not（0：void；1：int） function return（ret 0无返回值，1有返回值） call function name function call rparam ident_name dimension 函数实参get parameters ready for function call getint get a integer and put it into stack top print string para num pop values and print. dimarrayvar ident_name type/dimension set dimension info for array variety getvalue ident_name type/dimension 对于普通变量，get the variety value getaddress ident_name type/dimension 对于数组，get the variety address defaultvalue ident_name type/dimension push something to hold places exit exit 运算比较 CodeType Value1 Value2 Operation add + sub - mul * div / mod % cmpeq == cmpne != cmpgt \u0026gt; cmplt \u0026lt; cmpge \u0026gt;= cmple \u0026lt;= and \u0026amp;\u0026amp; or || not ! neg - pos + 短路求值问题 There are two situations I need to use short circuit calculation :\n1. if(a\u0026amp;\u0026amp;b) // a is false 2. if(a||b) // a is true My method is as follows:\nFirst, when I analyze analyseLOrExp, every analyseLAndExp will be followed by a JNZ, which is used for detect if the cond is true. If it is, jump to the if body label. At the same time, I generated cond label, which is ready for the analyseLAndExp.\nprivate void analyseLOrExp(ArrayList\u0026lt;Word\u0026gt; exp, String from) { ... for (...) { ... String label = labelGenerator.getLabel(\u0026#34;cond_\u0026#34; + i); analyseLAndExp(exp1, from, label); codes.add(new PCode(CodeType.LABEL, label)); if (...) { codes.add(new PCode(CodeType.OR)); } if (...) { if (...) { codes.add(new PCode(CodeType.JNZ, ifLabels.get(ifLabels.size() - 1).get(\u0026#34;if_block\u0026#34;))); } ... } ... } } In the analyseLAndExp, every analyseEqExp will be followed by a JZ, which is used for detect if the cond is true. If it is not, jump to the cond label I set just now.\nprivate void analyseLAndExp(ArrayList\u0026lt;Word\u0026gt; exp, String from, String label) { ... for (...) { ... analyseEqExp(exp1); if (...) { codes.add(new PCode(CodeType.AND)); } if (...) { if (...) { codes.add(new PCode(CodeType.JZ, label)); } ... } } } By these means, short circuit calculation is solved.\n七. 代码示例 int y=3; int b[1][3]={{1,2,3}}; int func(int x[][3]) { return x[0][2]+y; } int func2(int a) { int s=a+b; return a; } int main(){ int q=3; int x=q; int z; int y=func(b); z=func2(3); printf(\u0026#34;%d\u0026#34;,3); return 0; } var 0_y push 3 var 0_b push 1 push 3 dimarrayvar 0_b, 2 push 1 push 2 push 3 FUNC @func: push 3 fparam 1_x, 2 push 1_x push 0 push 2 getvalue 1_x, 0 push 0_y getvalue 0_y, 0 add ret 1 endfunc FUNC @func2: fparam 2_a, 0 var 2_s push 2_a getvalue 2_a, 0 push 0_b getaddress 0_b, 2 add push 2_a getvalue 2_a, 0 ret 1 endfunc mainfunc main var 3_q push 3 var 3_x push 3_q getvalue 3_q, 0 var 3_z defaultvalue 3_z, 0 var 3_y push 0_b getaddress 0_b, 2 rparam b, 2 $func push 3_z getaddress 3_z, 0 push 3 rparam 3, 0 $func2 pop 3_z push 3 print \u0026#34;%d\u0026#34; push 0 ret 1 exit ","permalink":"https://mksasx.github.io/posts/tech/compile/summary/","summary":"编译设计文档 姓名：马泽远 学号：20373793 一. 参考编译器介绍 Pcode代码生成部分（包括Pcode代码执行）部分参考了《自己动手写编译器","title":"编译期末总结文档"},{"content":"Lab6-Challenge 实验报告 实验概述 在本实验中，我通过编写新函数，新的方法实现一些小组件以及附加功能，丰富了我们的 shell的功能，包括\u0026quot;后台运行\u0026quot;，\u0026ldquo;一行多命令\u0026rdquo;，\u0026ldquo;简单引号支持\u0026rdquo;，\u0026ldquo;tree /mkdir /touch 命令\u0026rdquo;，\u0026ldquo;清屏\u0026rdquo;，\u0026ldquo;彩色输出\u0026rdquo;，\u0026ldquo;历史命令\u0026rdquo;，\u0026ldquo;环境变量\u0026rdquo;，\u0026ldquo;cd 命令\u0026quot;等任务。\n各部分实现思路及代码 Easy部分 （1）实现后台运行 1、首先在getc.S中，修改汇编代码，以防止前台被阻塞，手动忽略输入。\nLEAF(sys_cgetc) 1: lb t0, 0x90000000 //beqz t0, 1b //nop move v0,t0 jr ra nop END(sys_cgetc) 2、修改shell\n在sh.c中runcmd()定义一个变量 hang 标记是否要后台运行，初始化为0。\ncase \u0026#39;\u0026amp;\u0026#39;: hang = 1; break; 在运行命令的时候，若无\u0026amp;，正常等待程序运行结束，若有\u0026amp;，那么就调用fork()生成子进程，同时要防止阻塞，并且在程序运行结束后，输出提示信息。\n//无\u0026amp;，就等进程结束 if (!hang) wait(r); //有\u0026amp;，就fork一个子进程，等待新加载的程序运行完成，输出提示信息 else { pid = fork(); if (pid == 0) //创建cmd子进程 { wait(r); //等待新加载的程序运行完 writef(\u0026#34;\\n[%d] DONE\\t\u0026#34;, r);//提示信息 for (i = 0; i \u0026lt; argc; ++i) writef(\u0026#34;%s \u0026#34;, argv[i]); char curpath[MAXPATHLEN]; int envid = syscall_getenvid(); int shellid = syscall_getfaid(envid); curpath_get(shellid, curpath); writef(\u0026#34;\\n\u0026#34; LIGHT_BLUE(% s) \u0026#34; \u0026#34; BOLD_GREEN($) \u0026#34; \u0026#34;, curpath); writef(\u0026#34;\\b \\b\u0026#34;); exit(); } } （2）一行多命令 使用 fork 创建一个子进程执行已经识别的命令，cmd进程则继续解析下一条指令，需要注意的是，每一条指令运行前，都需要对相应的状态变量进行初始化，然后后一条指令在子进程运行结束后，再进行运行。\ncase \u0026#39;;\u0026#39;: if ((pid = fork()) == 0) //创建子进程 { goto runit; } wait(pid);//等待子进程运行结束 //参数重新初始化 argc = 0; hang = 0; rightpipe = 0; //父进程跳出switch， 继续解析下一个命令 file_input = -1; file_output = -1; break; （3）引号支持 修改 token 的部分，识别到引号的时候一直继续读，直到遇到下一个引号。\nif (*s == \u0026#39;\\\u0026#34;\u0026#39;) { *p1 = ++s; while (*s \u0026amp;\u0026amp; !(*s == \u0026#39;\\\u0026#34;\u0026#39; \u0026amp;\u0026amp; *(s - 1) != \u0026#39;\\\\\u0026#39;)) { ++s; } *s++ = 0; *p2 = s; return \u0026#39;w\u0026#39;; } （4）tree / mkdir /touch tree\n主函数tree()通过参数的解析来调用walk()\nvoid tree(char *path, char *prefix) { struct Stat status; int r = stat(path, \u0026amp;status); if (r \u0026lt; 0) user_panic(\u0026#34;stat %s: %e\u0026#34;, path, r); walk(path, 0); } walk()函数实现内部的递归调用,传入路径和层级数量,遍历文件。对于嵌套的目录，使用递归的方式遍历。\n输出时借助于层级数量来格式化输出结果。\nvoid walk(char *path, int len) { int dir_fd; struct File f; int i; char newpath[MAXPATHLEN] = {0}; dir_fd = open(path, O_RDONLY); if (dir_fd \u0026lt; 0) user_panic(\u0026#34;failed: open %s: %e\u0026#34;, *path*, dir_fd); while (readn(dir_fd, \u0026amp;f, sizeof (struct File)) == sizeof (struct File)) { if (f.f_name[0]) { struct File *dir = \u0026amp;f; //格式化输出 for (i = 0; i \u0026lt; len*4; i++) fwritef(1, \u0026#34; \u0026#34;); fwritef(1, \u0026#34;\\n\u0026#34;); for (i = 0; i \u0026lt; len*4; i++) fwritef(1, \u0026#34; \u0026#34;); fwritef(1, \u0026#34;|-- \u0026#34;); // 输出当前文件或目录 if (dir-\u0026gt;f_type == FTYPE_REG) { fwritef(1, YELLOW(%s), dir-\u0026gt;f_name); } //递归输出子目录 else if (dir-\u0026gt;f_type == FTYPE_DIR) { fwritef(1, PURPLE(%s), dir-\u0026gt;f_name); //拼接子目录路径 strcat(newpath, path); strcat(newpath, dir-\u0026gt;f_name); strcat(newpath, \u0026#34;/\u0026#34;); // writef(\u0026#34;nxtpath:\\n%s\u0026#34;, npath);* walk(newpath, len + 1); } } } } mkdir\n为了简化操作，实现后续mkdir，增加系统调用来实现获得shell的id\nu_int sys_get_ShellId(int *sysno*, u_int *envid*) { struct Env *e ; envid2env(*envid*, \u0026amp;e, 0); return e-\u0026gt;env_parent_id; } 得到当前地址curpath，拼接得到完整地址\n对O_MKDIR进行open\nvoid mkdir(char *path, char *prefix) { char curpath[MAXPATHLEN] = {0}; // writef(\u0026#34;mkdir :envid是 %d shellid是 %d\\n\u0026#34;, id, shellid); int r; //获取相应的id int id = syscall_getenvid(); int shellid = syscall_get_ShellId(syscall_get_ShellId(id)); if ((r = curpath_get(shellid, curpath) )\u0026lt; 0) user_panic(\u0026#34;mkdir: Error: curpath get\\n\u0026#34;); //path的拼接 if (path[0] == \u0026#39;/\u0026#39;) { strcat(curpath, path); } else { if (curpath[strlen(curpath) - 1] != \u0026#39;/\u0026#39;) strcat(curpath, \u0026#34;/\u0026#34;); strcat(curpath, path); } //调用open r = open(curpath, O_RDWR|O_MKDIR); if (r \u0026lt; 0) user_panic(\u0026#34;Directory %s created error\\n\u0026#34;, curpath); fwritef(1, \u0026#34;%s created successfully\\n\u0026#34;, curpath); } touch\n类似于mkdir，只不过是open的时候使用O_CREAT参数。\nvoid touch(char *path, char *prefix) { char curpath[MAXPATHLEN] = {0}; int r; //获取相应的id int id=syscall_getenvid(); int shell_id = syscall_get_ShellId(syscall_get_ShellId(id)); if ((r= curpath_get(shell_id, curpath)) \u0026lt; 0) { fwritef(1, \u0026#34;mkdir: Error: get curpath\\n\u0026#34;); return; } //path拼接 if (path[0] == \u0026#39;/\u0026#39;) { strcpy(curpath, path); } else { if (curpath[strlen(curpath) - 1] != \u0026#39;/\u0026#39;) strcat(curpath, \u0026#34;/\u0026#34;); strcat(curpath, path); } r = open(curpath, O_CREAT|O_RDWR); if (r \u0026lt; 0) { fwritef(1, \u0026#34;mkdir: Error: create file\\n\u0026#34;); return; } fwritef(1, \u0026#34;File %s created!\u0026#34;, curpath); } Normal部分 历史命令功能 首先创建读取/写入历史文件 API\nvoid history_init(); void history_save(char *s); int history_read(char(*cmd)[128]); 初始化函数\nvoid history_init() { int r; if ((r = open(\u0026#34;/.history\u0026#34;, O_CREAT | O_RDWR)) \u0026lt; 0) user_panic(\u0026#34;His : Init Failed: %d.\u0026#34;, r); } 将每一个输入执行的指令，利用history_save()保存进一个文件中，我创建的是.history文件，每行存放一条指令。\nvoid history_save(char *s) { int r; if ((r = open(\u0026#34;/.history\u0026#34;, O_CREAT | O_RDWR | O_APPEND)) \u0026lt; 0) { user_panic(\u0026#34;His : Open failed\u0026#34;); } fwritef(r, s); fwritef(r, \u0026#34;\\n\u0026#34;); close(r); } int history_read(char cmd[][128]) { int r, fd; char buf[128 * 128]; if ((fd = open(\u0026#34;/.history\u0026#34;, O_RDONLY)) \u0026lt; 0) { user_panic(\u0026#34;His : Open failed\u0026#34;); } if ((r = read(fd, buf, sizeof(buf))) \u0026lt; 0) { user_panic(\u0026#34;His : Read failed\u0026#34;); } close(fd); int i = 0, cmdi = 0; while (buf[i]) { int cmdj = 0; while (buf[i] \u0026amp;\u0026amp; buf[i] != \u0026#39;\\n\u0026#39;) cmd[cmdi][cmdj++] = buf[i++]; if (!buf[i]) break; ++i; ++cmdi; } return cmdi; } 通过编写一个用户态程序 history.b文件并写入磁盘中，使得每次调用history.b 时，能够将文件（ .history ）的内容全部输出。在 user/history.c 中 进行读取/.history文件\n#include \u0026#34;lib.h\u0026#34; void umain(int argc, char **argv) { if (argc != 1) { fwritef(1, \u0026#34;usage: history\\n\u0026#34;); return; } int his = open(\u0026#34;.history\u0026#34;, O_RDONLY | O_CREAT); char ch; fwritef(1, \u0026#34;\\x1b[33m-*- HISTORY -*-\\x1b[0m\\n\u0026#34;); fwritef(1, \u0026#34;\\x1b[33m1\\x1b[0m\\t\u0026#34;); int cnt = 1; int fl = 0; while (read(his, \u0026amp;ch, 1) == 1) { if (fl) { fwritef(1, \u0026#34;\\x1b[33m%d\\x1b[0m\\t\u0026#34;, cnt); fl = 0; } fwritef(1, \u0026#34;%c\u0026#34;, ch); if (ch == \u0026#39;\\n\u0026#39;) { cnt++; fl = 1; } } } 按键识别，键入上下键时，切换历史命令\n经查阅资料，光标键对应的字符如下：\n按键 常规模式 应用程序模式 ↑ ESC [ A ESC O A ↓ ESC [ B ESC O B 步骤\n获取缓冲区buf[]后三个字符 捕获到后，抵消光标移动操作 清空缓冲区，将光标移到左侧 打印出相应顺序的指令 代码分析\nif (i \u0026gt;= 2 \u0026amp;\u0026amp; buf[i - 2] == 27 \u0026amp;\u0026amp; buf[i - 1] == 91 \u0026amp;\u0026amp; buf[i] == 65) { writef(\u0026#34;%c%c%c\u0026#34;, 27, 91, 65); for (i -= 2; i; --i) writef(\u0026#34;\\b \\b\u0026#34;); if (cmdi) strcpy(buf, cmds[--cmdi]); else strcpy(buf, cmds[cmdi]); writef(\u0026#34;%s\u0026#34;, buf); i = strlen(buf) - 1; } else if (i \u0026gt;= 2 \u0026amp;\u0026amp; buf[i - 2] == 27 \u0026amp;\u0026amp; buf[i - 1] == 91 \u0026amp;\u0026amp; buf[i] == 66) { if (cmdi \u0026lt; nn - 1) { for (i -= 2; i; --i) writef(\u0026#34;\\b \\b\u0026#34;); strcpy(buf, cmds[++cmdi]); writef(\u0026#34;%s\u0026#34;, buf); } else { buf[i - 2] = buf[i - 1] = buf[i] = \u0026#39;\\0\u0026#39;; } i = strlen(buf) - 1; } Challenge部分 环境变量 在本部分，我与部分同学进行了进行了交流与探讨，最终结合助教的提示以及问题描述，得到了下面一种较为有效的解决方案。\n首先我们需要自定一个新的结构体，来表示环境变量，其中需要有这些属性：环境变量拥有者的id、环境变量的名字 、环境变量的值、只读性、局部性、有效性，然后建立一个环境变量表，以达到多个程序使用的目的\nstruct Var { int envid; //环境变量拥有者的id char name[64]; //环境变量的名字 char val[128]; //环境变量的值 int readonly; //只读性 int local; //局部性 int ava; //有效性,为0代表还未生效，即不存在（狭义理解） }; 新增系统调用,以实现对环境变量的增删改查\n在lib/syscall.S:\n.word sys_get_var .word sys_set_var user/syscall_lib.c\nint syscall_get_var(u_int envid, char *name, char *val, int op) { return msyscall(SYS_get_var, envid, name, val, op, 0); } int syscall_set_var(u_int envid, char *name, char *val, int op, int perm) { return msyscall(SYS_set_var, envid, name, val, op, perm); } 增：syscall_set_var(op=0)——遍历环境变量表，找到第一个ava=0的Var，写入这个Var\n删：syscall_set_var(op=1)——遍历环境变量表，找到name对应的要删除的var，设置其ava=0\n改：syscall_set_var(op=0)——遍历环境变量表，找到name对应的要修改的var，改为参数中的这个var\n查：查询特定的有效的环境变量/全部有效的环境变量\n特定的：syscall_get_var(op=0)——遍历环境变量表，找到所有ava=1的，且名字与查询条件相同的var 全部的：syscall_get_var(op=1)——遍历环境变量表，找到所有ava=1的var 具体代码实现，受限于篇幅，不完整贴上，需要注意的几点\n设置set时的权限位 VAR_LOCAL ， VAR_RDONLY 来控制访问权限,设置对应Var的local，readonly变量\n新增了错误类型 E_VAR_NOT_FOUND , E_VAR_FULL , E_VAR_RDONLY\n在进行后三者时，要注意额外判断当前维护变量是否为局部的以及其与当前shellid的关系，写一个简单的函数进行判断。\n//shellid通过系统调用传入 int judge(u_int shellid, struct Var *var) { if (var-\u0026gt;local == 0) { return 1; } else { if (shellid == var-\u0026gt;envid) { return 1; } else { return 0; } } } 主要使用strcat，strcmp，strcpy进行字符串处理，比较。利用了比较傻的for循环。\n然后比如说判断是否有对应name，构建了一个小函数，方便判断\nint contain_name(char *name) { int i = 0; for (i = 0; i \u0026lt; NVARS; i++) { struct Var *v = \u0026amp;vars[i]; if (v-\u0026gt;ava \u0026amp;\u0026amp; strcmp(v-\u0026gt;name, *name*) == 0) { return 1; } } return 0; } 注意权限位的设置\ndeclare\n在umain中，设置flag,以及perm\nvoid umain(int argc, char **argv) { int i; ARGBEGIN { default: usage(); case \u0026#39;r\u0026#39;: flag[(u_char) ARGC()]++; case \u0026#39;x\u0026#39;: flag[(u_char) ARGC()]++; break; } ARGEND int perm = 0; if (flag[\u0026#39;r\u0026#39;]) { perm |= VAR_RDONLY; } if (flag[\u0026#39;x\u0026#39;]) { perm |= VAR_LOCAL; } char *arg2 = argv[1]; while(*arg2 == \u0026#39;=\u0026#39;) { arg2++; } if (argc == 0) declare_nothing(); else if (argc == 1) set(argv[0], \u0026#34;\u0026#34;, perm); else if (argc == 2) set(argv[0], arg2, perm); else writef(1, \u0026#34;too many args\u0026#34;); //writef(\u0026#34;declare ok**\u0026#34;); } 在set函数中调用前述所写系统调用，实现declare，需要注意的是权限位的设定，以及传入参数\nvoid set(char *name, char *value, int perm) { int r; int shellid = syscall_get_ShellId(syscall_get_ShellId(syscall_getenvid())); if ((r = syscall_set_var(shellid, name, value, 0, perm)) \u0026lt; 0) { if (r == -E_VAR_FULL) fwritef(1, \u0026#34;declare: vars are full\\n\u0026#34;, name); if (r == -E_VAR_RDONLY) fwritef(1, \u0026#34;declare: [%s] is readonly\\n\u0026#34;, name); return; } } echo\n在实现echo的时候，在umain解析的时候，需要对其进行修改\nvoid umain(int argc, char **argv) { int i, nflag; nflag = 0; if (argc \u0026gt; 1 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-n\u0026#34;) == 0) { nflag = 1; argc--; argv++; } for (i = 1; i \u0026lt; argc; i++) { if (i \u0026gt; 1) write(1, \u0026#34; \u0026#34;, 1); if (argv[i][0] == \u0026#39;$\u0026#39;) { char value[128]; syscall_env_var(\u0026amp;argv[i][1], value, 1); write(1, value, strlen(value)); } else { write(1, argv[i], strlen(argv[i])); } } if (!nflag) write(1, \u0026#34;\\n\u0026#34;, 1); } unset\n在unset.c 中， 直接调用syscall_set_var 即可.\n其他支持或者前置条件 （1）clear清屏 #define CLEAR() printf(\u0026quot;\\033[2J\u0026quot;) （2）彩色输出 定义在sh.h中\n用类似于\\033[32m 实现绿色输出，类似可以实现其他颜色的输出。\n用 \\033[1m 可以实现加粗效果。\n用 \\033[m 表示颜色输出结束。\n（3）cd命令 利用环境变量维护curpath(当前路径)，利用系统调用可以获取和设置当前路径，并封装一套 API；\nvoid curpath_init(int envid,char *path); int curpath_get(int envid,char *path); int curpath_set(int envid,char *path); int curpath_get_parent(int envid,char *path); 当使用∶\ncd.∶不改变路径\ncd ..∶返回上一级目录（若为根目录，则不再返回）\ncd folder ∶进入目录时\n对所有的命令都重写，加入 curpath 的获取。如果传入的命令是一个以 /开头的路径，则为绝对路径;否则为相对路径。\nint i, r; int path[256]; int faid = syscall_get_ShellId(syscall_get_ShellId(syscall_getenvid())); if (argc == 1) { fwritef(1, \u0026#34;cd: too few args\\n\u0026#34;); return; } else { for (i = 1; i \u0026lt; argc; i++) { //显示当前目录 if (strcmp(argv[i], \u0026#34;.\u0026#34;) == 0) return; //上一级目录 if (strcmp(argv[i], \u0026#34;..\u0026#34;) == 0) { curpath_get_parent(faid, path); curpath_set(faid, path); fwritef(1, \u0026#34;cd(now_path): %s\u0026#34;, path); return; } else //进入某一个目录 { if ((r = curpath_get(faid, path)) \u0026lt; 0) { fwritef(1, \u0026#34;cd: get environment var failed\u0026#34;); return; } strcat(path, argv[i]); int len = strlen(path); if (path[len - 1] != \u0026#39;/\u0026#39;) strcat(path, \u0026#34;/\u0026#34;); struct Stat st; r = stat(path, \u0026amp;st); if (r == -E_VAR_NOT_FOUND) fwritef(1, \u0026#34;cd: %s not found\\n\u0026#34;, path); else if (r \u0026lt; 0) fwritef(1, \u0026#34;cd: cannot cd %s\\n\u0026#34;, path); else if (!st.st_isdir) fwritef(1, \u0026#34;cd: %s is not directory\\n\u0026#34;, path); else { if ((r = curpath_set(faid, path)) \u0026lt; 0) fwritef(1, \u0026#34;Environment var not found\u0026#34;); fwritef(1, \u0026#34;curpath: %s\u0026#34;, path); } return; } } } （4）rm命令 //类似于创建文件，有小改动 if ((r = remove(curpath)) \u0026lt; 0) { fwritef(1, \u0026#34;File %s Not Exists!\\n\u0026#34;, curpath); return; } （5）open修改 在open()中，首先需要加入APPEND,MKDIR,CREAT代码。\n#define O_APPEND 0x1000\nuser/file.c中的open() 中加入O_APPEND打开方式扩充代码\nif ((mode \u0026amp; O_APPEND) != 0) { ffd-\u0026gt;f_fd.fd_offset = size; } fs/serv.c中的serve_open()中加入CREAT, MKDIR打开方式扩充.\nif ((r = file_open((char *) path, \u0026amp;f)) \u0026lt; 0) { if (r == -E_NOT_FOUND \u0026amp;\u0026amp; (rq-\u0026gt;req_omode \u0026amp; O_CREAT)) { if ((r = file_create((char *)path, \u0026amp;f)) \u0026lt; 0) { return; } f-\u0026gt;f_type = FTYPE_REG; } else if (r == -E_NOT_FOUND \u0026amp;\u0026amp; (rq-\u0026gt;req_omode \u0026amp; O_MKDIR)) { if ((r = file_create((char *)path, \u0026amp;f)) \u0026lt; 0) { return; } f-\u0026gt;f_type = FTYPE_DIR; } else { ipc_send(envid, r, 0, 0); return; } } （6）环境变量的获取，当前地址的操作 void curpath_init(int envid, char *path) { int r; // set op 0 declare with perm if ((r = syscall_set_var(envid, CURPATH_KEY, path, 0, 0)) \u0026lt; 0) user_panic(\u0026#34;Init curpath failed: %u.\u0026#34;, r); return ; } int curpath_get(int envid, char *path) { int r; //op1 get one //writef(\u0026#34;get from env : %d\u0026#34;, envid); if ((r = syscall_get_var(envid, CURPATH_KEY, path, 1)) \u0026lt; 0) return r; return 0; } int curpath_set(int envid, char *path) { int r; // op0 declare with perm if ((r = syscall_set_var(envid, CURPATH_KEY, path, 0, 0)) \u0026lt; 0) return r; return r; } int curpath_get_parent(int envid, char *path) { int r, i; if ((r = curpath_get(envid, path)) \u0026lt; 0) return r; if (strlen(path) == 1) return 0; for (i = strlen(path) - 2; path[i - 1] != \u0026#39;/\u0026#39;; i--); path[i] = 0; return r; } 实验难点及总结 在本实验中，我通过编写新函数，新的方法实现一些小组件以及附加功能，丰富了我们的 shell的功能，包括\u0026quot;后台运行\u0026rdquo;，\u0026ldquo;一行多命令\u0026rdquo;，\u0026ldquo;简单引号支持\u0026rdquo;，\u0026ldquo;tree /mkdir /touch 命令\u0026rdquo;，\u0026ldquo;清屏\u0026rdquo;，\u0026ldquo;彩色输出\u0026rdquo;，\u0026ldquo;历史命令\u0026rdquo;，\u0026ldquo;环境变量\u0026rdquo;，\u0026ldquo;cd 命令\u0026quot;等任务。\n我认为实验的主要难点在于\n修改若干的指令，使之成为内置的指令 在历史命令中，如何实现识别键位（通过查阅资料得知），如何实现历史命令保存，输出 以及在challenge部分的环境变量的实现（新定义结构体，并且书写相应的系统调用，以及增加相应的open（）参数，错误码，并加以合理运用） 一些字符串处理方法的使用，以及各个细节的注意以及逐个击破。 终于度过了难捱的一学期学习，在做完了lab6挑战性任务以后，我对os的学习体会有了进一步的升华，也对课程内容有了更深入的理解，感谢os课程组对我们的磨练以及提升！\n","permalink":"https://mksasx.github.io/posts/tech/os/great/","summary":"Lab6-Challenge 实验报告 实验概述 在本实验中，我通过编写新函数，新的方法实现一些小组件以及附加功能，丰富了我们的 shell的功能，包括\u0026quot;后台运行\u0026","title":"操作系统申优文档"},{"content":"交换排序 以交换位置的方式排序\n冒泡排序 原理：把最大的换到最后一位，然后把第一大的换到倒数第二位\npublic static void bubbleSort(int[] args) { int len = args.length; while (len \u0026gt; 0) { for (int i = 0; i \u0026lt; len - 1; i++) { int next = i + 1; if (args[i] \u0026gt; args[next]) { int temp = args[next]; args[next] = args[i]; args[i] = temp; } } len--; } } 快速排序 原理：从数列中取出一个值，将比这个值大的放在它的右边，将比这个值小的放在它的左边，再最左右两个区域重复这个过程，直到各个区域只有一个数。\npublic void quickSort(int[] target, int left, int right) { if (left \u0026gt;= right) { return; } int pivot = target[left];// 基准点 int lo = left; int hi = right; while (lo \u0026lt; hi) { while (target[hi] \u0026gt;= pivot \u0026amp;\u0026amp; lo \u0026lt; hi) { hi--; } //把右边受阴元素和左边换 target[lo] = target[hi]; while (target[lo] \u0026lt;= pivot \u0026amp;\u0026amp; lo \u0026lt; hi) { lo++; } //把左边受阴元素和右边换 target[hi] = target[lo]; } //把拿出来的元素放回去 target[lo] = pivot; quickSort(target, left, lo - 1); quickSort(target, lo + 1, right); ","permalink":"https://mksasx.github.io/posts/tech/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"交换排序 以交换位置的方式排序 冒泡排序 原理：把最大的换到最后一位，然后把第一大的换到倒数第二位 public static void bubbleSort(int[] args) { int len = args.length; while (len \u0026gt; 0) { for (int i = 0; i \u0026lt; len -","title":"排序算法"},{"content":"","permalink":"https://mksasx.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"五一节摆烂啦！\n","permalink":"https://mksasx.github.io/posts/life/life/","summary":"五一节摆烂啦！","title":"五一节见闻"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\rsaltyfishyjk\u0026#39;s Blog\ryjk巨佬哥哥的博客\r","permalink":"https://mksasx.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 saltyfishyjk\u0026#39;s Blog yjk巨佬哥哥的博客","title":"🤝友链"},{"content":"马泽远 Austin Ma\n院校：\n北京航空航天大学 专业：\n软件工程 职业：\n学生 爱好：\n跑步、打篮球、唱歌 邮箱：\n1263122871@qq.com 个人简介：\n我来自于北京航空航天大学2020级软件学院，熟悉前端三件套以及VUE框架，python，java语言。目前感兴趣于CV方向，会写一些小网站 我的简历：\n点击下载 ","permalink":"https://mksasx.github.io/about/","summary":"我的个人信息","title":"🙋🏻‍♂️关于我"}]