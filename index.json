[{"content":"球星赛场照 ","permalink":"https://mksasx.github.io/posts/sport/bas_wallpaper/","summary":"一些篮球有关的壁纸","title":"篮球壁纸"},{"content":"写文章 快速写文章 输入hugo new 文章名称.md就会在content目录下生成 “文章名称.md” 名字的文件，所有文章都是放在content这个文件夹里\n如果自己还定义了分类目录，如在content目录的posts目录下有blog、read、tech、life等文章分类，那么在用命令生成文章的时候，如果要把文章生成到指定目录，可以用命令：hugo new posts/tech/文章名称.md，这样就会把文章生成到tech目录下\n生成的文章内部头部配置信息包括一些文章名称，时间之类的信息，可以事先在目录archetypes/default.md下使用模板，这样在用命令hugo new生成文章后会自动加上模板里的配置\n文章基本模板 --- title: \u0026#34;Blog\u0026#34; date: 2022-05-05T00:18:23+08:00 lastmod: 2022-05-05T00:18:23+08:00 author: [\u0026#34;AustinMa\u0026#34;] keywords: - 建站指南 categories: - 建站指南 tags: - blog description: \u0026#34;这是一些基础的建站指南\u0026#34; weight: 1 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true reward: true # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 cover: image: \u0026#34;\u0026#34; #图片路径例如：posts/tech/123/123.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; --- 文章插入图片 在文章里面使用本地图片的方式：\n比如我在content/posts/tech/下有一篇文章叫做 fft.md，那么在和该文章同一目录下新建一个文件夹叫做fft，里面放图片如叫做 picture.png 的图片，那么在fft.md里面调用的时候可以这样写: ![](picture.png)\n部署问题 写完文章更新Public hugo --theme=hugo-PaperMod --baseUrl=\u0026#34;https://mksasx.github.io/\u0026#34; --buildDrafts 或者\nhugo -F --cleanDestinationDir 部署到github样式不显示 错误描述 在 Github Pages 上部署 Hugo 博客后，网站样式丢失，打开浏览器 F12 控制台可以发现错误：Failed to find a valid digest in the 'integrity' attribute for resource \u0026quot;xxx.css\u0026quot;, The resource has been blocked.\n错误解决 将\\layouts\\partials\\head.html以及themes\\hugo-PaperMod\\layouts\\partials里的integrity=\u0026quot;{{ $stylesheet.Data.Integrity }}\u0026quot; 这么一句代码，把它改为 integrity=\u0026quot;\u0026quot; 然后重新发布\n有些使用者会部署到github，可能遇到跨系统的问题，如提示LF will be replaced by CRLF in ******，这时输入命令：git config core.autocrlf false，解决换行符自动转换的问题。\n提示LF will be replaced by CRLF in **** 错误描述 git add时提示LF will be replaced by CRLF in ****\n错误解决 输入命令：git config core.autocrlf false，解决换行符自动转换的问题。\n","permalink":"https://mksasx.github.io/posts/tech/blog/blog/","summary":"写文章 快速写文章 输入hugo new 文章名称.md就会在content目录下生成 “文章名称.md” 名字的文件，所有文章都是放在content这个文","title":"Blog"},{"content":"《Can you feel my love tonight》 \u003c!DOCTYPE HTML\u003e\r《Free Loop》 \u003c!DOCTYPE HTML\u003e\r《知足（阿卡贝拉）》 \u003c!DOCTYPE HTML\u003e\r《知足》 \u003c!DOCTYPE HTML\u003e\r《贝加尔湖畔（阿卡贝拉）》 \u003c!DOCTYPE HTML\u003e\r","permalink":"https://mksasx.github.io/posts/music/%E4%B8%AA%E4%BA%BA%E8%A1%A8%E6%BC%94%E5%90%88%E9%9B%86/","summary":"个人表演合集，阿卡贝拉","title":"个人一些表演合集"},{"content":"#include\u0026lt;bits/stdc++.h\u0026gt; #define N 2621450 #define pi acos(-1) using namespace std; typedef complex\u0026lt;double\u0026gt; E; int n,m,l,r[N]; E a[N],b[N]; void fft(E *a,int f){ for(int i=0;i\u0026lt;n;i++)if(i\u0026lt;r[i])swap(a[i],a[r[i]]); for(int i=1;i\u0026lt;n;i\u0026lt;\u0026lt;=1){ E wn(cos(pi/i),f*sin(pi/i)); for(int p=i\u0026lt;\u0026lt;1,j=0;j\u0026lt;n;j+=p){ E w(1,0); for(int k=0;k\u0026lt;i;k++,w*=wn){ E x=a[j+k],y=w*a[j+k+i]; a[j+k]=x+y;a[j+k+i]=x-y; } } } } inline int read(){ int f=1,x=0;char ch; do{ch=getchar();if(ch==\u0026#39;-\u0026#39;)f=-1;}while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;); do{x=x*10+ch-\u0026#39;0\u0026#39;;ch=getchar();}while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;); return f*x; } int main(){ n=read();m=read(); for(int i=0;i\u0026lt;=n;i++)a[i]=read(); for(int i=0;i\u0026lt;=m;i++)b[i]=read(); m+=n;for(n=1;n\u0026lt;=m;n\u0026lt;\u0026lt;=1)l++; for(int i=0;i\u0026lt;n;i++)r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); fft(a,1);fft(b,1); for(int i=0;i\u0026lt;=n;i++)a[i]=a[i]*b[i]; fft(a,-1); for(int i=0;i\u0026lt;=m;i++)printf(\u0026#34;%d \u0026#34;,(int)(a[i].real()/n+0.5)); } flowchart LR a--\u003eb \u0026 c--\u003ed ","permalink":"https://mksasx.github.io/posts/tech/algorithm/fft/","summary":"算法，快速傅里叶变化模板","title":"FFT模板"},{"content":"进攻站位 一内四外 单堆叠 防守站位 关门战术\r","permalink":"https://mksasx.github.io/posts/sport/%E7%AF%AE%E7%90%83%E5%9F%BA%E6%9C%AC%E6%88%98%E6%9C%AF%E5%8F%8A%E5%9B%BE%E8%A7%A3/","summary":"篮球基本战术及图解","title":"篮球基本战术及图解"},{"content":"Lab6-Challenge 实验报告 实验概述 在本实验中，我通过编写新函数，新的方法实现一些小组件以及附加功能，丰富了我们的 shell的功能，包括\u0026quot;后台运行\u0026quot;，\u0026ldquo;一行多命令\u0026rdquo;，\u0026ldquo;简单引号支持\u0026rdquo;，\u0026ldquo;tree /mkdir /touch 命令\u0026rdquo;，\u0026ldquo;清屏\u0026rdquo;，\u0026ldquo;彩色输出\u0026rdquo;，\u0026ldquo;历史命令\u0026rdquo;，\u0026ldquo;环境变量\u0026rdquo;，\u0026ldquo;cd 命令\u0026quot;等任务。\n各部分实现思路及代码 Easy部分 （1）实现后台运行 1、首先在getc.S中，修改汇编代码，以防止前台被阻塞，手动忽略输入。\nLEAF(sys_cgetc) 1: lb t0, 0x90000000 //beqz t0, 1b //nop move v0,t0 jr ra nop END(sys_cgetc) 2、修改shell\n在sh.c中runcmd()定义一个变量 hang 标记是否要后台运行，初始化为0。\ncase \u0026#39;\u0026amp;\u0026#39;: hang = 1; break; 在运行命令的时候，若无\u0026amp;，正常等待程序运行结束，若有\u0026amp;，那么就调用fork()生成子进程，同时要防止阻塞，并且在程序运行结束后，输出提示信息。\n//无\u0026amp;，就等进程结束 if (!hang) wait(r); //有\u0026amp;，就fork一个子进程，等待新加载的程序运行完成，输出提示信息 else { pid = fork(); if (pid == 0) //创建cmd子进程 { wait(r); //等待新加载的程序运行完 writef(\u0026#34;\\n[%d] DONE\\t\u0026#34;, r);//提示信息 for (i = 0; i \u0026lt; argc; ++i) writef(\u0026#34;%s \u0026#34;, argv[i]); char curpath[MAXPATHLEN]; int envid = syscall_getenvid(); int shellid = syscall_getfaid(envid); curpath_get(shellid, curpath); writef(\u0026#34;\\n\u0026#34; LIGHT_BLUE(% s) \u0026#34; \u0026#34; BOLD_GREEN($) \u0026#34; \u0026#34;, curpath); writef(\u0026#34;\\b \\b\u0026#34;); exit(); } } （2）一行多命令 使用 fork 创建一个子进程执行已经识别的命令，cmd进程则继续解析下一条指令，需要注意的是，每一条指令运行前，都需要对相应的状态变量进行初始化，然后后一条指令在子进程运行结束后，再进行运行。\ncase \u0026#39;;\u0026#39;: if ((pid = fork()) == 0) //创建子进程 { goto runit; } wait(pid);//等待子进程运行结束 //参数重新初始化 argc = 0; hang = 0; rightpipe = 0; //父进程跳出switch， 继续解析下一个命令 file_input = -1; file_output = -1; break; （3）引号支持 修改 token 的部分，识别到引号的时候一直继续读，直到遇到下一个引号。\nif (*s == \u0026#39;\\\u0026#34;\u0026#39;) { *p1 = ++s; while (*s \u0026amp;\u0026amp; !(*s == \u0026#39;\\\u0026#34;\u0026#39; \u0026amp;\u0026amp; *(s - 1) != \u0026#39;\\\\\u0026#39;)) { ++s; } *s++ = 0; *p2 = s; return \u0026#39;w\u0026#39;; } （4）tree / mkdir /touch tree\n主函数tree()通过参数的解析来调用walk()\nvoid tree(char *path, char *prefix) { struct Stat status; int r = stat(path, \u0026amp;status); if (r \u0026lt; 0) user_panic(\u0026#34;stat %s: %e\u0026#34;, path, r); walk(path, 0); } walk()函数实现内部的递归调用,传入路径和层级数量,遍历文件。对于嵌套的目录，使用递归的方式遍历。\n输出时借助于层级数量来格式化输出结果。\nvoid walk(char *path, int len) { int dir_fd; struct File f; int i; char newpath[MAXPATHLEN] = {0}; dir_fd = open(path, O_RDONLY); if (dir_fd \u0026lt; 0) user_panic(\u0026#34;failed: open %s: %e\u0026#34;, *path*, dir_fd); while (readn(dir_fd, \u0026amp;f, sizeof (struct File)) == sizeof (struct File)) { if (f.f_name[0]) { struct File *dir = \u0026amp;f; //格式化输出 for (i = 0; i \u0026lt; len*4; i++) fwritef(1, \u0026#34; \u0026#34;); fwritef(1, \u0026#34;\\n\u0026#34;); for (i = 0; i \u0026lt; len*4; i++) fwritef(1, \u0026#34; \u0026#34;); fwritef(1, \u0026#34;|-- \u0026#34;); // 输出当前文件或目录 if (dir-\u0026gt;f_type == FTYPE_REG) { fwritef(1, YELLOW(%s), dir-\u0026gt;f_name); } //递归输出子目录 else if (dir-\u0026gt;f_type == FTYPE_DIR) { fwritef(1, PURPLE(%s), dir-\u0026gt;f_name); //拼接子目录路径 strcat(newpath, path); strcat(newpath, dir-\u0026gt;f_name); strcat(newpath, \u0026#34;/\u0026#34;); // writef(\u0026#34;nxtpath:\\n%s\u0026#34;, npath);* walk(newpath, len + 1); } } } } mkdir\n为了简化操作，实现后续mkdir，增加系统调用来实现获得shell的id\nu_int sys_get_ShellId(int *sysno*, u_int *envid*) { struct Env *e ; envid2env(*envid*, \u0026amp;e, 0); return e-\u0026gt;env_parent_id; } 得到当前地址curpath，拼接得到完整地址\n对O_MKDIR进行open\nvoid mkdir(char *path, char *prefix) { char curpath[MAXPATHLEN] = {0}; // writef(\u0026#34;mkdir :envid是 %d shellid是 %d\\n\u0026#34;, id, shellid); int r; //获取相应的id int id = syscall_getenvid(); int shellid = syscall_get_ShellId(syscall_get_ShellId(id)); if ((r = curpath_get(shellid, curpath) )\u0026lt; 0) user_panic(\u0026#34;mkdir: Error: curpath get\\n\u0026#34;); //path的拼接 if (path[0] == \u0026#39;/\u0026#39;) { strcat(curpath, path); } else { if (curpath[strlen(curpath) - 1] != \u0026#39;/\u0026#39;) strcat(curpath, \u0026#34;/\u0026#34;); strcat(curpath, path); } //调用open r = open(curpath, O_RDWR|O_MKDIR); if (r \u0026lt; 0) user_panic(\u0026#34;Directory %s created error\\n\u0026#34;, curpath); fwritef(1, \u0026#34;%s created successfully\\n\u0026#34;, curpath); } touch\n类似于mkdir，只不过是open的时候使用O_CREAT参数。\nvoid touch(char *path, char *prefix) { char curpath[MAXPATHLEN] = {0}; int r; //获取相应的id int id=syscall_getenvid(); int shell_id = syscall_get_ShellId(syscall_get_ShellId(id)); if ((r= curpath_get(shell_id, curpath)) \u0026lt; 0) { fwritef(1, \u0026#34;mkdir: Error: get curpath\\n\u0026#34;); return; } //path拼接 if (path[0] == \u0026#39;/\u0026#39;) { strcpy(curpath, path); } else { if (curpath[strlen(curpath) - 1] != \u0026#39;/\u0026#39;) strcat(curpath, \u0026#34;/\u0026#34;); strcat(curpath, path); } r = open(curpath, O_CREAT|O_RDWR); if (r \u0026lt; 0) { fwritef(1, \u0026#34;mkdir: Error: create file\\n\u0026#34;); return; } fwritef(1, \u0026#34;File %s created!\u0026#34;, curpath); } Normal部分 历史命令功能 首先创建读取/写入历史文件 API\nvoid history_init(); void history_save(char *s); int history_read(char(*cmd)[128]); 初始化函数\nvoid history_init() { int r; if ((r = open(\u0026#34;/.history\u0026#34;, O_CREAT | O_RDWR)) \u0026lt; 0) user_panic(\u0026#34;His : Init Failed: %d.\u0026#34;, r); } 将每一个输入执行的指令，利用history_save()保存进一个文件中，我创建的是.history文件，每行存放一条指令。\nvoid history_save(char *s) { int r; if ((r = open(\u0026#34;/.history\u0026#34;, O_CREAT | O_RDWR | O_APPEND)) \u0026lt; 0) { user_panic(\u0026#34;His : Open failed\u0026#34;); } fwritef(r, s); fwritef(r, \u0026#34;\\n\u0026#34;); close(r); } int history_read(char cmd[][128]) { int r, fd; char buf[128 * 128]; if ((fd = open(\u0026#34;/.history\u0026#34;, O_RDONLY)) \u0026lt; 0) { user_panic(\u0026#34;His : Open failed\u0026#34;); } if ((r = read(fd, buf, sizeof(buf))) \u0026lt; 0) { user_panic(\u0026#34;His : Read failed\u0026#34;); } close(fd); int i = 0, cmdi = 0; while (buf[i]) { int cmdj = 0; while (buf[i] \u0026amp;\u0026amp; buf[i] != \u0026#39;\\n\u0026#39;) cmd[cmdi][cmdj++] = buf[i++]; if (!buf[i]) break; ++i; ++cmdi; } return cmdi; } 通过编写一个用户态程序 history.b文件并写入磁盘中，使得每次调用history.b 时，能够将文件（ .history ）的内容全部输出。在 user/history.c 中 进行读取/.history文件\n#include \u0026#34;lib.h\u0026#34; void umain(int argc, char **argv) { if (argc != 1) { fwritef(1, \u0026#34;usage: history\\n\u0026#34;); return; } int his = open(\u0026#34;.history\u0026#34;, O_RDONLY | O_CREAT); char ch; fwritef(1, \u0026#34;\\x1b[33m-*- HISTORY -*-\\x1b[0m\\n\u0026#34;); fwritef(1, \u0026#34;\\x1b[33m1\\x1b[0m\\t\u0026#34;); int cnt = 1; int fl = 0; while (read(his, \u0026amp;ch, 1) == 1) { if (fl) { fwritef(1, \u0026#34;\\x1b[33m%d\\x1b[0m\\t\u0026#34;, cnt); fl = 0; } fwritef(1, \u0026#34;%c\u0026#34;, ch); if (ch == \u0026#39;\\n\u0026#39;) { cnt++; fl = 1; } } } 按键识别，键入上下键时，切换历史命令\n经查阅资料，光标键对应的字符如下：\n按键 常规模式 应用程序模式 ↑ ESC [ A ESC O A ↓ ESC [ B ESC O B 步骤\n获取缓冲区buf[]后三个字符 捕获到后，抵消光标移动操作 清空缓冲区，将光标移到左侧 打印出相应顺序的指令 代码分析\nif (i \u0026gt;= 2 \u0026amp;\u0026amp; buf[i - 2] == 27 \u0026amp;\u0026amp; buf[i - 1] == 91 \u0026amp;\u0026amp; buf[i] == 65) { writef(\u0026#34;%c%c%c\u0026#34;, 27, 91, 65); for (i -= 2; i; --i) writef(\u0026#34;\\b \\b\u0026#34;); if (cmdi) strcpy(buf, cmds[--cmdi]); else strcpy(buf, cmds[cmdi]); writef(\u0026#34;%s\u0026#34;, buf); i = strlen(buf) - 1; } else if (i \u0026gt;= 2 \u0026amp;\u0026amp; buf[i - 2] == 27 \u0026amp;\u0026amp; buf[i - 1] == 91 \u0026amp;\u0026amp; buf[i] == 66) { if (cmdi \u0026lt; nn - 1) { for (i -= 2; i; --i) writef(\u0026#34;\\b \\b\u0026#34;); strcpy(buf, cmds[++cmdi]); writef(\u0026#34;%s\u0026#34;, buf); } else { buf[i - 2] = buf[i - 1] = buf[i] = \u0026#39;\\0\u0026#39;; } i = strlen(buf) - 1; } Challenge部分 环境变量 在本部分，我与部分同学进行了进行了交流与探讨，最终结合助教的提示以及问题描述，得到了下面一种较为有效的解决方案。\n首先我们需要自定一个新的结构体，来表示环境变量，其中需要有这些属性：环境变量拥有者的id、环境变量的名字 、环境变量的值、只读性、局部性、有效性，然后建立一个环境变量表，以达到多个程序使用的目的\nstruct Var { int envid; //环境变量拥有者的id char name[64]; //环境变量的名字 char val[128]; //环境变量的值 int readonly; //只读性 int local; //局部性 int ava; //有效性,为0代表还未生效，即不存在（狭义理解） }; 新增系统调用,以实现对环境变量的增删改查\n在lib/syscall.S:\n.word sys_get_var .word sys_set_var user/syscall_lib.c\nint syscall_get_var(u_int envid, char *name, char *val, int op) { return msyscall(SYS_get_var, envid, name, val, op, 0); } int syscall_set_var(u_int envid, char *name, char *val, int op, int perm) { return msyscall(SYS_set_var, envid, name, val, op, perm); } 增：syscall_set_var(op=0)——遍历环境变量表，找到第一个ava=0的Var，写入这个Var\n删：syscall_set_var(op=1)——遍历环境变量表，找到name对应的要删除的var，设置其ava=0\n改：syscall_set_var(op=0)——遍历环境变量表，找到name对应的要修改的var，改为参数中的这个var\n查：查询特定的有效的环境变量/全部有效的环境变量\n特定的：syscall_get_var(op=0)——遍历环境变量表，找到所有ava=1的，且名字与查询条件相同的var 全部的：syscall_get_var(op=1)——遍历环境变量表，找到所有ava=1的var 具体代码实现，受限于篇幅，不完整贴上，需要注意的几点\n设置set时的权限位 VAR_LOCAL ， VAR_RDONLY 来控制访问权限,设置对应Var的local，readonly变量\n新增了错误类型 E_VAR_NOT_FOUND , E_VAR_FULL , E_VAR_RDONLY\n在进行后三者时，要注意额外判断当前维护变量是否为局部的以及其与当前shellid的关系，写一个简单的函数进行判断。\n//shellid通过系统调用传入 int judge(u_int shellid, struct Var *var) { if (var-\u0026gt;local == 0) { return 1; } else { if (shellid == var-\u0026gt;envid) { return 1; } else { return 0; } } } 主要使用strcat，strcmp，strcpy进行字符串处理，比较。利用了比较傻的for循环。\n然后比如说判断是否有对应name，构建了一个小函数，方便判断\nint contain_name(char *name) { int i = 0; for (i = 0; i \u0026lt; NVARS; i++) { struct Var *v = \u0026amp;vars[i]; if (v-\u0026gt;ava \u0026amp;\u0026amp; strcmp(v-\u0026gt;name, *name*) == 0) { return 1; } } return 0; } 注意权限位的设置\ndeclare\n在umain中，设置flag,以及perm\nvoid umain(int argc, char **argv) { int i; ARGBEGIN { default: usage(); case \u0026#39;r\u0026#39;: flag[(u_char) ARGC()]++; case \u0026#39;x\u0026#39;: flag[(u_char) ARGC()]++; break; } ARGEND int perm = 0; if (flag[\u0026#39;r\u0026#39;]) { perm |= VAR_RDONLY; } if (flag[\u0026#39;x\u0026#39;]) { perm |= VAR_LOCAL; } char *arg2 = argv[1]; while(*arg2 == \u0026#39;=\u0026#39;) { arg2++; } if (argc == 0) declare_nothing(); else if (argc == 1) set(argv[0], \u0026#34;\u0026#34;, perm); else if (argc == 2) set(argv[0], arg2, perm); else writef(1, \u0026#34;too many args\u0026#34;); //writef(\u0026#34;declare ok**\u0026#34;); } 在set函数中调用前述所写系统调用，实现declare，需要注意的是权限位的设定，以及传入参数\nvoid set(char *name, char *value, int perm) { int r; int shellid = syscall_get_ShellId(syscall_get_ShellId(syscall_getenvid())); if ((r = syscall_set_var(shellid, name, value, 0, perm)) \u0026lt; 0) { if (r == -E_VAR_FULL) fwritef(1, \u0026#34;declare: vars are full\\n\u0026#34;, name); if (r == -E_VAR_RDONLY) fwritef(1, \u0026#34;declare: [%s] is readonly\\n\u0026#34;, name); return; } } echo\n在实现echo的时候，在umain解析的时候，需要对其进行修改\nvoid umain(int argc, char **argv) { int i, nflag; nflag = 0; if (argc \u0026gt; 1 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-n\u0026#34;) == 0) { nflag = 1; argc--; argv++; } for (i = 1; i \u0026lt; argc; i++) { if (i \u0026gt; 1) write(1, \u0026#34; \u0026#34;, 1); if (argv[i][0] == \u0026#39;$\u0026#39;) { char value[128]; syscall_env_var(\u0026amp;argv[i][1], value, 1); write(1, value, strlen(value)); } else { write(1, argv[i], strlen(argv[i])); } } if (!nflag) write(1, \u0026#34;\\n\u0026#34;, 1); } unset\n在unset.c 中， 直接调用syscall_set_var 即可.\n其他支持或者前置条件 （1）clear清屏 #define CLEAR() printf(\u0026quot;\\033[2J\u0026quot;) （2）彩色输出 定义在sh.h中\n用类似于\\033[32m 实现绿色输出，类似可以实现其他颜色的输出。\n用 \\033[1m 可以实现加粗效果。\n用 \\033[m 表示颜色输出结束。\n（3）cd命令 利用环境变量维护curpath(当前路径)，利用系统调用可以获取和设置当前路径，并封装一套 API；\nvoid curpath_init(int envid,char *path); int curpath_get(int envid,char *path); int curpath_set(int envid,char *path); int curpath_get_parent(int envid,char *path); 当使用∶\ncd.∶不改变路径\ncd ..∶返回上一级目录（若为根目录，则不再返回）\ncd folder ∶进入目录时\n对所有的命令都重写，加入 curpath 的获取。如果传入的命令是一个以 /开头的路径，则为绝对路径;否则为相对路径。\nint i, r; int path[256]; int faid = syscall_get_ShellId(syscall_get_ShellId(syscall_getenvid())); if (argc == 1) { fwritef(1, \u0026#34;cd: too few args\\n\u0026#34;); return; } else { for (i = 1; i \u0026lt; argc; i++) { //显示当前目录 if (strcmp(argv[i], \u0026#34;.\u0026#34;) == 0) return; //上一级目录 if (strcmp(argv[i], \u0026#34;..\u0026#34;) == 0) { curpath_get_parent(faid, path); curpath_set(faid, path); fwritef(1, \u0026#34;cd(now_path): %s\u0026#34;, path); return; } else //进入某一个目录 { if ((r = curpath_get(faid, path)) \u0026lt; 0) { fwritef(1, \u0026#34;cd: get environment var failed\u0026#34;); return; } strcat(path, argv[i]); int len = strlen(path); if (path[len - 1] != \u0026#39;/\u0026#39;) strcat(path, \u0026#34;/\u0026#34;); struct Stat st; r = stat(path, \u0026amp;st); if (r == -E_VAR_NOT_FOUND) fwritef(1, \u0026#34;cd: %s not found\\n\u0026#34;, path); else if (r \u0026lt; 0) fwritef(1, \u0026#34;cd: cannot cd %s\\n\u0026#34;, path); else if (!st.st_isdir) fwritef(1, \u0026#34;cd: %s is not directory\\n\u0026#34;, path); else { if ((r = curpath_set(faid, path)) \u0026lt; 0) fwritef(1, \u0026#34;Environment var not found\u0026#34;); fwritef(1, \u0026#34;curpath: %s\u0026#34;, path); } return; } } } （4）rm命令 //类似于创建文件，有小改动 if ((r = remove(curpath)) \u0026lt; 0) { fwritef(1, \u0026#34;File %s Not Exists!\\n\u0026#34;, curpath); return; } （5）open修改 在open()中，首先需要加入APPEND,MKDIR,CREAT代码。\n#define O_APPEND 0x1000\nuser/file.c中的open() 中加入O_APPEND打开方式扩充代码\nif ((mode \u0026amp; O_APPEND) != 0) { ffd-\u0026gt;f_fd.fd_offset = size; } fs/serv.c中的serve_open()中加入CREAT, MKDIR打开方式扩充.\nif ((r = file_open((char *) path, \u0026amp;f)) \u0026lt; 0) { if (r == -E_NOT_FOUND \u0026amp;\u0026amp; (rq-\u0026gt;req_omode \u0026amp; O_CREAT)) { if ((r = file_create((char *)path, \u0026amp;f)) \u0026lt; 0) { return; } f-\u0026gt;f_type = FTYPE_REG; } else if (r == -E_NOT_FOUND \u0026amp;\u0026amp; (rq-\u0026gt;req_omode \u0026amp; O_MKDIR)) { if ((r = file_create((char *)path, \u0026amp;f)) \u0026lt; 0) { return; } f-\u0026gt;f_type = FTYPE_DIR; } else { ipc_send(envid, r, 0, 0); return; } } （6）环境变量的获取，当前地址的操作 void curpath_init(int envid, char *path) { int r; // set op 0 declare with perm if ((r = syscall_set_var(envid, CURPATH_KEY, path, 0, 0)) \u0026lt; 0) user_panic(\u0026#34;Init curpath failed: %u.\u0026#34;, r); return ; } int curpath_get(int envid, char *path) { int r; //op1 get one //writef(\u0026#34;get from env : %d\u0026#34;, envid); if ((r = syscall_get_var(envid, CURPATH_KEY, path, 1)) \u0026lt; 0) return r; return 0; } int curpath_set(int envid, char *path) { int r; // op0 declare with perm if ((r = syscall_set_var(envid, CURPATH_KEY, path, 0, 0)) \u0026lt; 0) return r; return r; } int curpath_get_parent(int envid, char *path) { int r, i; if ((r = curpath_get(envid, path)) \u0026lt; 0) return r; if (strlen(path) == 1) return 0; for (i = strlen(path) - 2; path[i - 1] != \u0026#39;/\u0026#39;; i--); path[i] = 0; return r; } 实验难点及总结 在本实验中，我通过编写新函数，新的方法实现一些小组件以及附加功能，丰富了我们的 shell的功能，包括\u0026quot;后台运行\u0026rdquo;，\u0026ldquo;一行多命令\u0026rdquo;，\u0026ldquo;简单引号支持\u0026rdquo;，\u0026ldquo;tree /mkdir /touch 命令\u0026rdquo;，\u0026ldquo;清屏\u0026rdquo;，\u0026ldquo;彩色输出\u0026rdquo;，\u0026ldquo;历史命令\u0026rdquo;，\u0026ldquo;环境变量\u0026rdquo;，\u0026ldquo;cd 命令\u0026quot;等任务。\n我认为实验的主要难点在于\n修改若干的指令，使之成为内置的指令 在历史命令中，如何实现识别键位（通过查阅资料得知），如何实现历史命令保存，输出 以及在challenge部分的环境变量的实现（新定义结构体，并且书写相应的系统调用，以及增加相应的open（）参数，错误码，并加以合理运用） 一些字符串处理方法的使用，以及各个细节的注意以及逐个击破。 终于度过了难捱的一学期学习，在做完了lab6挑战性任务以后，我对os的学习体会有了进一步的升华，也对课程内容有了更深入的理解，感谢os课程组对我们的磨练以及提升！\n","permalink":"https://mksasx.github.io/posts/tech/os/great/","summary":"Lab6-Challenge 实验报告 实验概述 在本实验中，我通过编写新函数，新的方法实现一些小组件以及附加功能，丰富了我们的 shell的功能，包括\u0026quot;后台运行\u0026","title":"操作系统申优文档"},{"content":"交换排序 以交换位置的方式排序\n冒泡排序 原理：把最大的换到最后一位，然后把第一大的换到倒数第二位\npublic static void bubbleSort(int[] args) { int len = args.length; while (len \u0026gt; 0) { for (int i = 0; i \u0026lt; len - 1; i++) { int next = i + 1; if (args[i] \u0026gt; args[next]) { int temp = args[next]; args[next] = args[i]; args[i] = temp; } } len--; } } 快速排序 原理：从数列中取出一个值，将比这个值大的放在它的右边，将比这个值小的放在它的左边，再最左右两个区域重复这个过程，直到各个区域只有一个数。\npublic void quickSort(int[] target, int left, int right) { if (left \u0026gt;= right) { return; } int pivot = target[left];// 基准点 int lo = left; int hi = right; while (lo \u0026lt; hi) { while (target[hi] \u0026gt;= pivot \u0026amp;\u0026amp; lo \u0026lt; hi) { hi--; } //把右边受阴元素和左边换 target[lo] = target[hi]; while (target[lo] \u0026lt;= pivot \u0026amp;\u0026amp; lo \u0026lt; hi) { lo++; } //把左边受阴元素和右边换 target[hi] = target[lo]; } //把拿出来的元素放回去 target[lo] = pivot; quickSort(target, left, lo - 1); quickSort(target, lo + 1, right); ","permalink":"https://mksasx.github.io/posts/tech/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"交换排序 以交换位置的方式排序 冒泡排序 原理：把最大的换到最后一位，然后把第一大的换到倒数第二位 public static void bubbleSort(int[] args) { int len = args.length; while (len \u0026gt; 0) { for (int i = 0; i \u0026lt; len -","title":"排序算法"},{"content":"","permalink":"https://mksasx.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"五一节摆烂啦！\n","permalink":"https://mksasx.github.io/posts/life/life/","summary":"五一节摆烂啦！","title":"五一节见闻"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\rsaltyfishyjk\u0026#39;s Blog\ryjk巨佬哥哥的博客\r","permalink":"https://mksasx.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 saltyfishyjk\u0026#39;s Blog yjk巨佬哥哥的博客","title":"🤝友链"},{"content":" 中文名: 马泽远 英文名: Austin Ma 职业: 大学生 爱好: 跑步、打篮球、唱歌 简介: 我来自于北京航空航天大学2020级软件学院，目前感兴趣于CV方向，会写一些小网站 联系邮箱: 1263122871@qq.com 个人简历 ","permalink":"https://mksasx.github.io/about/","summary":"我的个人信息","title":"🙋🏻‍♂️关于我"}]